Module: RSpec::Matchers
  
  
  
Module: RSpec::Matchers
  
  
  


  

  
  
  
      Extended by:Extended by:
      DSLDSL
  
      Extended by:
      DSL
  
  
  
  
  

  
  
    Included in:Included in:
    DSL::MatcherDSL::Matcher
  
    Included in:
    DSL::Matcher
  
  

  
  
    Defined in:Defined in:
    lib/rspec/matchers.rb
lib/rspec/matchers.rb

  
    Defined in:
    lib/rspec/matchers.rb

  
  

  

  
  
  
      Extended by:
      DSL
  
  
  
  
  

  
  
    Included in:
    DSL::Matcher
  
  

  
  
    Defined in:
    lib/rspec/matchers.rb

  
  


OverviewOverview
  
    RSpec::Matchers provides a number of useful matchers we use to define expectations. Any object that implements the matcher protocol can be used as a matcher.RSpec::Matchers provides a number of useful matchers we use to define expectations. Any object that implements the matcher protocol can be used as a matcher.

PredicatesPredicates

In addition to matchers that are defined explicitly, RSpec will create custom matchers on the fly for any arbitrary predicate, giving your specs a much more natural language feel.In addition to matchers that are defined explicitly, RSpec will create custom matchers on the fly for any arbitrary predicate, giving your specs a much more natural language feel.

A Ruby predicate is a method that ends with a "?" and returns true or false. Common examples are empty?, nil?, and instance_of?.A Ruby predicate is a method that ends with a "?" and returns true or false. Common examples are empty?, nil?, and instance_of?.

All you need to do is write expect(..).to be_ followed by the predicate without the question mark, and RSpec will figure it out from there. For example:.All you need to do is write expect(..).to be_ followed by the predicate without the question mark, and RSpec will figure it out from there. For example:.

expectexpect(([[]]))..toto be_emptybe_empty     # => [].empty?() | passes
# => [].empty?() | passes
expectexpect(([[]]))..not_tonot_to be_emptybe_empty # => [].empty?() | fails
# => [].empty?() | fails
expect([]).to be_empty     # => [].empty?() | passes
expect([]).not_to be_empty # => [].empty?() | fails
expect([]).to be_empty     # => [].empty?() | passes
expect([]).not_to be_empty # => [].empty?() | fails


In addtion to prefixing the predicate matchers with "be", you can also use "be_a" and "bean", making your specs read much more naturally:.In addtion to prefixing the predicate matchers with "be", you can also use "be_a" and "bean", making your specs read much more naturally:.

expectexpect((""a stringa string"""a string"))..toto be_an_instance_ofbe_an_instance_of((StringString)) # =>"a string".instance_of?(String) # passes
# =>"a string".instance_of?(String) # passes

expectexpect((33))..toto be_a_kind_ofbe_a_kind_of((IntegerInteger))          # => 3.kind_of?(Numeric)     | passes
# => 3.kind_of?(Numeric)     | passes
expectexpect((33))..toto be_a_kind_ofbe_a_kind_of((NumericNumeric))          # => 3.kind_of?(Numeric)     | passes
# => 3.kind_of?(Numeric)     | passes
expectexpect((33))..toto be_an_instance_ofbe_an_instance_of((IntegerInteger))     # => 3.instance_of?(Integer) | passes
# => 3.instance_of?(Integer) | passes
expectexpect((33))..not_tonot_to be_an_instance_ofbe_an_instance_of((NumericNumeric)) # => 3.instance_of?(Numeric) | fails
# => 3.instance_of?(Numeric) | fails
expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes

expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails
expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes

expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails


RSpec will also create custom matchers for predicates like has_key?. To use this feature, just state that the object should have_key(:key) and RSpec will call has_key?(:key) on the target. For example:.RSpec will also create custom matchers for predicates like has_key?. To use this feature, just state that the object should have_key(:key) and RSpec will call has_key?(:key) on the target. For example:.

expectexpect((:a:a =>=> ""AA"""A"))..toto have_keyhave_key((:a:a))
expectexpect((:a:a =>=> ""AA"""A"))..toto have_keyhave_key((:b:b)) # fails
# fails
expect(:a => "A").to have_key(:a)
expect(:a => "A").to have_key(:b) # fails
expect(:a => "A").to have_key(:a)
expect(:a => "A").to have_key(:b) # fails


You can use this feature to invoke any predicate that begins with "has_", whether it is part of the Ruby libraries (like Hash#has_key?) or a method you wrote on your own class.You can use this feature to invoke any predicate that begins with "has_", whether it is part of the Ruby libraries (like Hash#has_key?) or a method you wrote on your own class.

Note that RSpec does not provide composable aliases for these dynamic predicate matchers. You can easily define your own aliases, though:.Note that RSpec does not provide composable aliases for these dynamic predicate matchers. You can easily define your own aliases, though:.

RSpecRSpec::::MatchersMatchers..alias_matcheralias_matcher :a_user_who_is_an_admin:a_user_who_is_an_admin,, :be_an_admin:be_an_admin
expectexpect((user_listuser_list))..toto includeinclude((a_user_who_is_an_admina_user_who_is_an_admin))
RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
expect(user_list).to include(a_user_who_is_an_admin)
RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
expect(user_list).to include(a_user_who_is_an_admin)


Alias MatchersAlias Matchers

With Matchers.alias_matcher, you can easily create an alternate name for a given matcher.With Matchers.alias_matcher, you can easily create an alternate name for a given matcher.

The description will also change according to the new name:.The description will also change according to the new name:.

RSpecRSpec::::MatchersMatchers..alias_matcheralias_matcher :a_list_that_sums_to:a_list_that_sums_to,, :sum_to:sum_to
sum_tosum_to((33))..descriptiondescription # => "sum to 3"
# => "sum to 3"
a_list_that_sums_toa_list_that_sums_to((33))..descriptiondescription # => "a list that sums to 3"
# => "a list that sums to 3"
RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
sum_to(3).description # => "sum to 3"
a_list_that_sums_to(3).description # => "a list that sums to 3"
RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
sum_to(3).description # => "sum to 3"
a_list_that_sums_to(3).description # => "a list that sums to 3"


or you can specify a custom description like this:.or you can specify a custom description like this:.

RSpecRSpec::::MatchersMatchers..alias_matcheralias_matcher :a_list_sorted_by:a_list_sorted_by,, :be_sorted_by:be_sorted_by dodo ||descriptiondescription||
  descriptiondescription..subsub((""be sorted bybe sorted by"""be sorted by",, ""a list sorted bya list sorted by"""a list sorted by"))
endend

be_sorted_bybe_sorted_by((:age:age))..descriptiondescription # => "be sorted by age"
# => "be sorted by age"
a_list_sorted_bya_list_sorted_by((:age:age))..descriptiondescription # => "a list sorted by age"
# => "a list sorted by age"
RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  description.sub("be sorted by", "a list sorted by")
end

be_sorted_by(:age).description # => "be sorted by age"
a_list_sorted_by(:age).description # => "a list sorted by age"
RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  description.sub("be sorted by", "a list sorted by")
end

be_sorted_by(:age).description # => "be sorted by age"
a_list_sorted_by(:age).description # => "a list sorted by age"


Custom MatchersCustom Matchers

When you find that none of the stock matchers provide a natural feeling expectation, you can very easily write your own using RSpec's matcher DSL or writing one from scratch.When you find that none of the stock matchers provide a natural feeling expectation, you can very easily write your own using RSpec's matcher DSL or writing one from scratch.

Matcher DSLMatcher DSL

Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:.Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:.

expectexpect((bobbob..current_zonecurrent_zone))..toto eqleql((ZoneZone..newnew((""44"""4"))))
expect(bob.current_zone).to eql(Zone.new("4"))
expect(bob.current_zone).to eql(Zone.new("4"))


But you might find it more expressive to say:.But you might find it more expressive to say:.

expectexpect((bobbob))..toto be_in_zonebe_in_zone((""44"""4"))
expect(bob).to be_in_zone("4")
expect(bob).to be_in_zone("4")


and/or.and/or.

expectexpect((bobbob))..not_tonot_to be_in_zonebe_in_zone((""33"""3"))
expect(bob).not_to be_in_zone("3")
expect(bob).not_to be_in_zone("3")


You can create such a matcher like so:.You can create such a matcher like so:.

RSpecRSpec::::MatchersMatchers..definedefine :be_in_zone:be_in_zone dodo ||zonezone||
  matchmatch dodo ||playerplayer||
    playerplayer..in_zone?in_zone?((zonezone))
  endend
endend
RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end
end
RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end
end


This will generate a be_in_zone method that returns a matcher with logical default messages for failures. You can override the failure messages and the generated description as follows:.This will generate a be_in_zone method that returns a matcher with logical default messages for failures. You can override the failure messages and the generated description as follows:.

RSpecRSpec::::MatchersMatchers..definedefine :be_in_zone:be_in_zone dodo ||zonezone||
  matchmatch dodo ||playerplayer||
    playerplayer..in_zone?in_zone?((zonezone))
  endend

  failure_messagefailure_message dodo ||playerplayer||
    # generate and return the appropriate string.
# generate and return the appropriate string.
  endend

  failure_message_when_negatedfailure_message_when_negated dodo ||playerplayer||
    # generate and return the appropriate string.
# generate and return the appropriate string.
  endend

  descriptiondescription dodo
    # generate and return the appropriate string.
# generate and return the appropriate string.
  endend
endend
RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end

  failure_message do |player|
    # generate and return the appropriate string.
  end

  failure_message_when_negated do |player|
    # generate and return the appropriate string.
  end

  description do
    # generate and return the appropriate string.
  end
end
RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end

  failure_message do |player|
    # generate and return the appropriate string.
  end

  failure_message_when_negated do |player|
    # generate and return the appropriate string.
  end

  description do
    # generate and return the appropriate string.
  end
end


Each of the message-generation methods has access to the block arguments passed to the create method (in this case, zone). The failure message methods (failure_message and failure_message_when_negated) are passed the actual value (the receiver of expect(..) or expect(..).not_to).Each of the message-generation methods has access to the block arguments passed to the create method (in this case, zone). The failure message methods (failure_message and failure_message_when_negated) are passed the actual value (the receiver of expect(..) or expect(..).not_to).

Custom Matcher from scratchCustom Matcher from scratch

You could also write a custom matcher from scratch, as follows:.You could also write a custom matcher from scratch, as follows:.

classclass BeInZoneBeInZone
  defdef initializeinitialize((expectedexpected))
    @expected@expected == expectedexpected
  endend

  defdef matches?matches?((targettarget))
    @target@target == targettarget
    @target@target..current_zonecurrent_zone..eql?eql?((ZoneZone..newnew((@expected@expected))))
  endend

  defdef failure_messagefailure_message
    ""expected expected #{#{@target@target..inspectinspect}} to be in Zone  to be in Zone #{#{@expected@expected}}"""expected #{@target.inspect} to be in Zone #{@expected}"
  endend

  defdef failure_message_when_negatedfailure_message_when_negated
    ""expected expected #{#{@target@target..inspectinspect}} not to be in Zone  not to be in Zone #{#{@expected@expected}}"""expected #{@target.inspect} not to be in Zone #{@expected}"
  endend
endend
class BeInZone
  def initialize(expected)
    @expected = expected
  end

  def matches?(target)
    @target = target
    @target.current_zone.eql?(Zone.new(@expected))
  end

  def failure_message
    "expected #{@target.inspect} to be in Zone #{@expected}"
  end

  def failure_message_when_negated
    "expected #{@target.inspect} not to be in Zone #{@expected}"
  end
end
class BeInZone
  def initialize(expected)
    @expected = expected
  end

  def matches?(target)
    @target = target
    @target.current_zone.eql?(Zone.new(@expected))
  end

  def failure_message
    "expected #{@target.inspect} to be in Zone #{@expected}"
  end

  def failure_message_when_negated
    "expected #{@target.inspect} not to be in Zone #{@expected}"
  end
end


... and a method like this:.... and a method like this:.

defdef be_in_zonebe_in_zone((expectedexpected))
  BeInZoneBeInZone..newnew((expectedexpected))
endend
def be_in_zone(expected)
  BeInZone.new(expected)
end
def be_in_zone(expected)
  BeInZone.new(expected)
end


And then expose the method to your specs. This is normally done by including the method and the class in a module, which is then included in your spec:.And then expose the method to your specs. This is normally done by including the method and the class in a module, which is then included in your spec:.

modulemodule CustomGameMatchersCustomGameMatchers
  classclass BeInZoneBeInZone
    # ...
# ...
  endend

  defdef be_in_zonebe_in_zone((expectedexpected))
    # ...
# ...
  endend
endend

describedescribe ""Player behaviourPlayer behaviour"""Player behaviour" dodo
  includeinclude CustomGameMatchersCustomGameMatchers
  # ...
# ...
endend
module CustomGameMatchers
  class BeInZone
    # ...
  end

  def be_in_zone(expected)
    # ...
  end
end

describe "Player behaviour" do
  include CustomGameMatchers
  # ...
end
module CustomGameMatchers
  class BeInZone
    # ...
  end

  def be_in_zone(expected)
    # ...
  end
end

describe "Player behaviour" do
  include CustomGameMatchers
  # ...
end


or you can include in globally in a spec_helper.rb file required from your spec file(s):.or you can include in globally in a spec_helper.rb file required from your spec file(s):.

RSpecRSpec::::configureconfigure dodo ||configconfig||
  configconfig..includeinclude((CustomGameMatchersCustomGameMatchers))
endend
RSpec::configure do |config|
  config.include(CustomGameMatchers)
end
RSpec::configure do |config|
  config.include(CustomGameMatchers)
end


Making custom matchers composableMaking custom matchers composable

RSpec's built-in matchers are designed to be composed, in expressions like:.RSpec's built-in matchers are designed to be composed, in expressions like:.

expectexpect(([[""barnbarn"""barn",, 2.452.45]]))..toto contain_exactlycontain_exactly((
  a_value_withina_value_within((0.10.1))..ofof((2.52.5)),,
  a_string_starting_witha_string_starting_with((""barbar"""bar"))
))
expect(["barn", 2.45]).to contain_exactly(
  a_value_within(0.1).of(2.5),
  a_string_starting_with("bar")
)
expect(["barn", 2.45]).to contain_exactly(
  a_value_within(0.1).of(2.5),
  a_string_starting_with("bar")
)


Custom matchers can easily participate in composed matcher expressions like these. Include Composable in your custom matcher to make it support being composed (matchers defined using the DSL have this included automatically). Within your matcher's matches? method (or the match block, if using the DSL), use values_match?(expected, actual) rather than expected == actual. Under the covers, values_match? is able to match arbitrary nested data structures containing a mix of both matchers and non-matcher objects. It uses === and == to perform the matching, considering the values to match if either returns true. The Composable mixin also provides some helper methods for surfacing the matcher descriptions within your matcher's description or failure messages.Custom matchers can easily participate in composed matcher expressions like these. Include Composable in your custom matcher to make it support being composed (matchers defined using the DSL have this included automatically). Within your matcher's matches? method (or the match block, if using the DSL), use values_match?(expected, actual) rather than expected == actual. Under the covers, values_match? is able to match arbitrary nested data structures containing a mix of both matchers and non-matcher objects. It uses === and == to perform the matching, considering the values to match if either returns true. The Composable mixin also provides some helper methods for surfacing the matcher descriptions within your matcher's description or failure messages.

RSpec's built-in matchers each have a number of aliases that rephrase the matcher from a verb phrase (such as be_within) to a noun phrase (such as a_value_within), which reads better when the matcher is passed as an argument in a composed matcher expressions, and also uses the noun-phrase wording in the matcher's description, for readable failure messages. You can alias your custom matchers in similar fashion using Matchers.alias_matcher.RSpec's built-in matchers each have a number of aliases that rephrase the matcher from a verb phrase (such as be_within) to a noun phrase (such as a_value_within), which reads better when the matcher is passed as an argument in a composed matcher expressions, and also uses the noun-phrase wording in the matcher's description, for readable failure messages. You can alias your custom matchers in similar fashion using Matchers.alias_matcher.

Negated MatchersNegated Matchers

Sometimes if you want to test for the opposite using a more descriptive name instead of using not_to, you can use Matchers.define_negated_matcher:.Sometimes if you want to test for the opposite using a more descriptive name instead of using not_to, you can use Matchers.define_negated_matcher:.

RSpecRSpec::::MatchersMatchers..define_negated_matcherdefine_negated_matcher :exclude:exclude,, :include:include
includeinclude((11,, 22))..descriptiondescription # => "include 1 and 2"
# => "include 1 and 2"
excludeexclude((11,, 22))..descriptiondescription # => "exclude 1 and 2"
# => "exclude 1 and 2"
RSpec::Matchers.define_negated_matcher :exclude, :include
include(1, 2).description # => "include 1 and 2"
exclude(1, 2).description # => "exclude 1 and 2"
RSpec::Matchers.define_negated_matcher :exclude, :include
include(1, 2).description # => "include 1 and 2"
exclude(1, 2).description # => "exclude 1 and 2"


While the most obvious negated form may be to add a not_ prefix, the failure messages you get with that form can be confusing (e.g. "expected [actual] to not [verb], but did not"). We've found it works best to find a more positive name for the negated form, such as avoid_changing rather than not_change.While the most obvious negated form may be to add a not_ prefix, the failure messages you get with that form can be confusing (e.g. "expected [actual] to not [verb], but did not"). We've found it works best to find a more positive name for the negated form, such as avoid_changing rather than not_change.


  
    RSpec::Matchers provides a number of useful matchers we use to define expectations. Any object that implements the matcher protocol can be used as a matcher.

Predicates

In addition to matchers that are defined explicitly, RSpec will create custom matchers on the fly for any arbitrary predicate, giving your specs a much more natural language feel.

A Ruby predicate is a method that ends with a "?" and returns true or false. Common examples are empty?, nil?, and instance_of?.

All you need to do is write expect(..).to be_ followed by the predicate without the question mark, and RSpec will figure it out from there. For example:.

expect([]).to be_empty     # => [].empty?() | passes
expect([]).not_to be_empty # => [].empty?() | fails


In addtion to prefixing the predicate matchers with "be", you can also use "be_a" and "bean", making your specs read much more naturally:.

expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes

expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails


RSpec will also create custom matchers for predicates like has_key?. To use this feature, just state that the object should have_key(:key) and RSpec will call has_key?(:key) on the target. For example:.

expect(:a => "A").to have_key(:a)
expect(:a => "A").to have_key(:b) # fails


You can use this feature to invoke any predicate that begins with "has_", whether it is part of the Ruby libraries (like Hash#has_key?) or a method you wrote on your own class.

Note that RSpec does not provide composable aliases for these dynamic predicate matchers. You can easily define your own aliases, though:.

RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
expect(user_list).to include(a_user_who_is_an_admin)


Alias Matchers

With Matchers.alias_matcher, you can easily create an alternate name for a given matcher.

The description will also change according to the new name:.

RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
sum_to(3).description # => "sum to 3"
a_list_that_sums_to(3).description # => "a list that sums to 3"


or you can specify a custom description like this:.

RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  description.sub("be sorted by", "a list sorted by")
end

be_sorted_by(:age).description # => "be sorted by age"
a_list_sorted_by(:age).description # => "a list sorted by age"


Custom Matchers

When you find that none of the stock matchers provide a natural feeling expectation, you can very easily write your own using RSpec's matcher DSL or writing one from scratch.

Matcher DSL

Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:.

expect(bob.current_zone).to eql(Zone.new("4"))


But you might find it more expressive to say:.

expect(bob).to be_in_zone("4")


and/or.

expect(bob).not_to be_in_zone("3")


You can create such a matcher like so:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end
end


This will generate a be_in_zone method that returns a matcher with logical default messages for failures. You can override the failure messages and the generated description as follows:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end

  failure_message do |player|
    # generate and return the appropriate string.
  end

  failure_message_when_negated do |player|
    # generate and return the appropriate string.
  end

  description do
    # generate and return the appropriate string.
  end
end


Each of the message-generation methods has access to the block arguments passed to the create method (in this case, zone). The failure message methods (failure_message and failure_message_when_negated) are passed the actual value (the receiver of expect(..) or expect(..).not_to).

Custom Matcher from scratch

You could also write a custom matcher from scratch, as follows:.

class BeInZone
  def initialize(expected)
    @expected = expected
  end

  def matches?(target)
    @target = target
    @target.current_zone.eql?(Zone.new(@expected))
  end

  def failure_message
    "expected #{@target.inspect} to be in Zone #{@expected}"
  end

  def failure_message_when_negated
    "expected #{@target.inspect} not to be in Zone #{@expected}"
  end
end


... and a method like this:.

def be_in_zone(expected)
  BeInZone.new(expected)
end


And then expose the method to your specs. This is normally done by including the method and the class in a module, which is then included in your spec:.

module CustomGameMatchers
  class BeInZone
    # ...
  end

  def be_in_zone(expected)
    # ...
  end
end

describe "Player behaviour" do
  include CustomGameMatchers
  # ...
end


or you can include in globally in a spec_helper.rb file required from your spec file(s):.

RSpec::configure do |config|
  config.include(CustomGameMatchers)
end


Making custom matchers composable

RSpec's built-in matchers are designed to be composed, in expressions like:.

expect(["barn", 2.45]).to contain_exactly(
  a_value_within(0.1).of(2.5),
  a_string_starting_with("bar")
)


Custom matchers can easily participate in composed matcher expressions like these. Include Composable in your custom matcher to make it support being composed (matchers defined using the DSL have this included automatically). Within your matcher's matches? method (or the match block, if using the DSL), use values_match?(expected, actual) rather than expected == actual. Under the covers, values_match? is able to match arbitrary nested data structures containing a mix of both matchers and non-matcher objects. It uses === and == to perform the matching, considering the values to match if either returns true. The Composable mixin also provides some helper methods for surfacing the matcher descriptions within your matcher's description or failure messages.

RSpec's built-in matchers each have a number of aliases that rephrase the matcher from a verb phrase (such as be_within) to a noun phrase (such as a_value_within), which reads better when the matcher is passed as an argument in a composed matcher expressions, and also uses the noun-phrase wording in the matcher's description, for readable failure messages. You can alias your custom matchers in similar fashion using Matchers.alias_matcher.

Negated Matchers

Sometimes if you want to test for the opposite using a more descriptive name instead of using not_to, you can use Matchers.define_negated_matcher:.

RSpec::Matchers.define_negated_matcher :exclude, :include
include(1, 2).description # => "include 1 and 2"
exclude(1, 2).description # => "exclude 1 and 2"


While the most obvious negated form may be to add a not_ prefix, the failure messages you get with that form can be confusing (e.g. "expected [actual] to not [verb], but did not"). We've found it works best to find a more positive name for the negated form, such as avoid_changing rather than not_change.


  

  
    RSpec::Matchers provides a number of useful matchers we use to define expectations. Any object that implements the matcher protocol can be used as a matcher.

Predicates

In addition to matchers that are defined explicitly, RSpec will create custom matchers on the fly for any arbitrary predicate, giving your specs a much more natural language feel.

A Ruby predicate is a method that ends with a "?" and returns true or false. Common examples are empty?, nil?, and instance_of?.

All you need to do is write expect(..).to be_ followed by the predicate without the question mark, and RSpec will figure it out from there. For example:.

expect([]).to be_empty     # => [].empty?() | passes
expect([]).not_to be_empty # => [].empty?() | fails


In addtion to prefixing the predicate matchers with "be", you can also use "be_a" and "bean", making your specs read much more naturally:.

expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes

expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails


RSpec will also create custom matchers for predicates like has_key?. To use this feature, just state that the object should have_key(:key) and RSpec will call has_key?(:key) on the target. For example:.

expect(:a => "A").to have_key(:a)
expect(:a => "A").to have_key(:b) # fails


You can use this feature to invoke any predicate that begins with "has_", whether it is part of the Ruby libraries (like Hash#has_key?) or a method you wrote on your own class.

Note that RSpec does not provide composable aliases for these dynamic predicate matchers. You can easily define your own aliases, though:.

RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
expect(user_list).to include(a_user_who_is_an_admin)


Alias Matchers

With Matchers.alias_matcher, you can easily create an alternate name for a given matcher.

The description will also change according to the new name:.

RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
sum_to(3).description # => "sum to 3"
a_list_that_sums_to(3).description # => "a list that sums to 3"


or you can specify a custom description like this:.

RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  description.sub("be sorted by", "a list sorted by")
end

be_sorted_by(:age).description # => "be sorted by age"
a_list_sorted_by(:age).description # => "a list sorted by age"


Custom Matchers

When you find that none of the stock matchers provide a natural feeling expectation, you can very easily write your own using RSpec's matcher DSL or writing one from scratch.

Matcher DSL

Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:.

expect(bob.current_zone).to eql(Zone.new("4"))


But you might find it more expressive to say:.

expect(bob).to be_in_zone("4")


and/or.

expect(bob).not_to be_in_zone("3")


You can create such a matcher like so:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end
end


This will generate a be_in_zone method that returns a matcher with logical default messages for failures. You can override the failure messages and the generated description as follows:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end

  failure_message do |player|
    # generate and return the appropriate string.
  end

  failure_message_when_negated do |player|
    # generate and return the appropriate string.
  end

  description do
    # generate and return the appropriate string.
  end
end


Each of the message-generation methods has access to the block arguments passed to the create method (in this case, zone). The failure message methods (failure_message and failure_message_when_negated) are passed the actual value (the receiver of expect(..) or expect(..).not_to).

Custom Matcher from scratch

You could also write a custom matcher from scratch, as follows:.

class BeInZone
  def initialize(expected)
    @expected = expected
  end

  def matches?(target)
    @target = target
    @target.current_zone.eql?(Zone.new(@expected))
  end

  def failure_message
    "expected #{@target.inspect} to be in Zone #{@expected}"
  end

  def failure_message_when_negated
    "expected #{@target.inspect} not to be in Zone #{@expected}"
  end
end


... and a method like this:.

def be_in_zone(expected)
  BeInZone.new(expected)
end


And then expose the method to your specs. This is normally done by including the method and the class in a module, which is then included in your spec:.

module CustomGameMatchers
  class BeInZone
    # ...
  end

  def be_in_zone(expected)
    # ...
  end
end

describe "Player behaviour" do
  include CustomGameMatchers
  # ...
end


or you can include in globally in a spec_helper.rb file required from your spec file(s):.

RSpec::configure do |config|
  config.include(CustomGameMatchers)
end


Making custom matchers composable

RSpec's built-in matchers are designed to be composed, in expressions like:.

expect(["barn", 2.45]).to contain_exactly(
  a_value_within(0.1).of(2.5),
  a_string_starting_with("bar")
)


Custom matchers can easily participate in composed matcher expressions like these. Include Composable in your custom matcher to make it support being composed (matchers defined using the DSL have this included automatically). Within your matcher's matches? method (or the match block, if using the DSL), use values_match?(expected, actual) rather than expected == actual. Under the covers, values_match? is able to match arbitrary nested data structures containing a mix of both matchers and non-matcher objects. It uses === and == to perform the matching, considering the values to match if either returns true. The Composable mixin also provides some helper methods for surfacing the matcher descriptions within your matcher's description or failure messages.

RSpec's built-in matchers each have a number of aliases that rephrase the matcher from a verb phrase (such as be_within) to a noun phrase (such as a_value_within), which reads better when the matcher is passed as an argument in a composed matcher expressions, and also uses the noun-phrase wording in the matcher's description, for readable failure messages. You can alias your custom matchers in similar fashion using Matchers.alias_matcher.

Negated Matchers

Sometimes if you want to test for the opposite using a more descriptive name instead of using not_to, you can use Matchers.define_negated_matcher:.

RSpec::Matchers.define_negated_matcher :exclude, :include
include(1, 2).description # => "include 1 and 2"
exclude(1, 2).description # => "exclude 1 and 2"


While the most obvious negated form may be to add a not_ prefix, the failure messages you get with that form can be confusing (e.g. "expected [actual] to not [verb], but did not"). We've found it works best to find a more positive name for the negated form, such as avoid_changing rather than not_change.


  


  


  

Defined Under NamespaceDefined Under Namespace

  
    
      Modules:Modules: BuiltIn, Composable, DSL, EnglishPhrasing, FailMatchers
    
  
    
      Classes:Classes: AliasedMatcher, ExpectedsForMultipleDiffs, MatcherProtocol
    
  

  
    
      Modules: BuiltIn, Composable, DSL, EnglishPhrasing, FailMatchers
    
  
    
      Classes: AliasedMatcher, ExpectedsForMultipleDiffs, MatcherProtocol
    
  








  
    
      Class Method Summary
      
    
      Class Method Summary
      
    

    
      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#alias_matcher.Extended from DSL#alias_matcher.
Extended from DSL#alias_matcher.
Extended from DSL#alias_matcher.

  

  
  
  
  
  
  
  
  

  
    Extended from DSL#alias_matcher.

  


      
        
  
  
  
  
  
  
  
  privateprivate

  
    Used by rspec-core to clear the state used to generate descriptions after an example.Used by rspec-core to clear the state used to generate descriptions after an example.
Used by rspec-core to clear the state used to generate descriptions after an example.
Used by rspec-core to clear the state used to generate descriptions after an example.

  

  
  
  
  
  
  
  
  private

  
    Used by rspec-core to clear the state used to generate descriptions after an example.

  


      
        
  
  
  
  
  
  
  
  

  
    Delegates to Expectations.configuration.Delegates to Expectations.configuration.
Delegates to Expectations.configuration.
Delegates to Expectations.configuration.

  

  
  
  
  
  
  
  
  

  
    Delegates to Expectations.configuration.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define.Extended from DSL#define.
Extended from DSL#define.
Extended from DSL#define.

  

  
  
  
  
  
  
  
  

  
    Extended from DSL#define.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define_negated_matcher.Extended from DSL#define_negated_matcher.
Extended from DSL#define_negated_matcher.
Extended from DSL#define_negated_matcher.

  

  
  
  
  
  
  
  
  

  
    Extended from DSL#define_negated_matcher.

  


      
        
  
  
  
  
  
  
  
  privateprivate

  
    Generates an an example description based on the last expectation.Generates an an example description based on the last expectation.
Generates an an example description based on the last expectation.
Generates an an example description based on the last expectation.

  

  
  
  
  
  
  
  
  private

  
    Generates an an example description based on the last expectation.

  


      
    
      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#alias_matcher.

  


      
        
  
  
  
  
  
  
  
  private

  
    Used by rspec-core to clear the state used to generate descriptions after an example.

  


      
        
  
  
  
  
  
  
  
  

  
    Delegates to Expectations.configuration.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define_negated_matcher.

  


      
        
  
  
  
  
  
  
  
  private

  
    Generates an an example description based on the last expectation.

  


      
    
  
    
      Instance Method Summary
      
    
      Instance Method Summary
      
    

    
      
        
  
  
  
  
  
  
  
  

  
    Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.
Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.
Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.

  

  
  
  
  
  
  
  
  

  
    Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the provided matcher passes when checked against all elements of the collection.Passes if the provided matcher passes when checked against all elements of the collection.
Passes if the provided matcher passes when checked against all elements of the collection.
Passes if the provided matcher passes when checked against all elements of the collection.

  

  
  
  
  
  
  
  
  

  
    Passes if the provided matcher passes when checked against all elements of the collection.

  


      
        
  
  
  
  
  
  
  
  

  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively).Given true, false, or nil, will pass if actual value is true, false or nil (respectively).
Given true, false, or nil, will pass if actual value is true, false or nil (respectively).
Given true, false, or nil, will pass if actual value is true, false or nil (respectively).

  

  
  
  
  
  
  
  
  

  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively).

  


      
        
  
  
  
  
  
  
  
  

  
    passes if target.kind_of?(klass).passes if target.kind_of?(klass).
passes if target.kind_of?(klass).
passes if target.kind_of?(klass).

  

  
  
  
  
  
  
  
  

  
    passes if target.kind_of?(klass).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.kind_of?(expected).Passes if actual.kind_of?(expected).
Passes if actual.kind_of?(expected).
Passes if actual.kind_of?(expected).

  

  
  
  
  
  
  
  
  

  
    Passes if actual.kind_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.instance_of?(expected).Passes if actual.instance_of?(expected).
Passes if actual.instance_of?(expected).
Passes if actual.instance_of?(expected).

  

  
  
  
  
  
  
  
  

  
    Passes if actual.instance_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.between?(min, max).Passes if actual.between?(min, max).
Passes if actual.between?(min, max).
Passes if actual.between?(min, max).

  

  
  
  
  
  
  
  
  

  
    Passes if actual.between?(min, max).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is falsey (false or nil).Passes if actual is falsey (false or nil).
Passes if actual is falsey (false or nil).
Passes if actual is falsey (false or nil).

  

  
  
  
  
  
  
  
  

  
    Passes if actual is falsey (false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is nil.Passes if actual is nil.
Passes if actual is nil.
Passes if actual is nil.

  

  
  
  
  
  
  
  
  

  
    Passes if actual is nil.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is truthy (anything but false or nil).Passes if actual is truthy (anything but false or nil).
Passes if actual is truthy (anything but false or nil).
Passes if actual is truthy (anything but false or nil).

  

  
  
  
  
  
  
  
  

  
    Passes if actual is truthy (anything but false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected +/- delta.Passes if actual == expected +/- delta.
Passes if actual == expected +/- delta.
Passes if actual == expected +/- delta.

  

  
  
  
  
  
  
  
  

  
    Passes if actual == expected +/- delta.

  


      
        
  
  
  
  
  
  
  
  

  
    Applied to a proc, specifies that its execution will cause some value to change.Applied to a proc, specifies that its execution will cause some value to change.
Applied to a proc, specifies that its execution will cause some value to change.
Applied to a proc, specifies that its execution will cause some value to change.

  

  
  
  
  
  
  
  
  

  
    Applied to a proc, specifies that its execution will cause some value to change.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual contains all of the expected regardless of order.Passes if actual contains all of the expected regardless of order.
Passes if actual contains all of the expected regardless of order.
Passes if actual contains all of the expected regardless of order.

  

  
  
  
  
  
  
  
  

  
    Passes if actual contains all of the expected regardless of order.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual covers expected.Passes if actual covers expected.
Passes if actual covers expected.
Passes if actual covers expected.

  

  
  
  
  
  
  
  
  

  
    Passes if actual covers expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value ends with the expected value(s).Matches if the actual value ends with the expected value(s).
Matches if the actual value ends with the expected value(s).
Matches if the actual value ends with the expected value(s).

  

  
  
  
  
  
  
  
  

  
    Matches if the actual value ends with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected.Passes if actual == expected.
Passes if actual == expected.
Passes if actual == expected.

  

  
  
  
  
  
  
  
  

  
    Passes if actual == expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.eql?(expected).Passes if actual.eql?(expected).
Passes if actual.eql?(expected).
Passes if actual.eql?(expected).

  

  
  
  
  
  
  
  
  

  
    Passes if actual.eql?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.equal?(expected) (object identity).Passes if actual.equal?(expected) (object identity).
Passes if actual.equal?(expected) (object identity).
Passes if actual.equal?(expected) (object identity).

  

  
  
  
  
  
  
  
  

  
    Passes if actual.equal?(expected) (object identity).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.exist? or actual.exists?.Passes if actual.exist? or actual.exists?.
Passes if actual.exist? or actual.exists?.
Passes if actual.exist? or actual.exists?.

  

  
  
  
  
  
  
  
  

  
    Passes if actual.exist? or actual.exists?.

  


      
        
  
  
  
  
  
  
  
  

  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.
Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.
Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.

  

  
  
  
  
  
  
  
  

  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual's attribute values match the expected attributes hash.Passes if actual's attribute values match the expected attributes hash.
Passes if actual's attribute values match the expected attributes hash.
Passes if actual's attribute values match the expected attributes hash.

  

  
  
  
  
  
  
  
  

  
    Passes if actual's attribute values match the expected attributes hash.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual includes expected.Passes if actual includes expected.
Passes if actual includes expected.
Passes if actual includes expected.

  

  
  
  
  
  
  
  
  

  
    Passes if actual includes expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.
Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.
Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.

  

  
  
  
  
  
  
  
  

  
    Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.

  


      
        
  
  
  
  
  
  
  
  

  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.
An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.
An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.

  

  
  
  
  
  
  
  
  

  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.

  


      
        
  
  
  
  
  
  
  
  

  
    With no arg, passes if the block outputs to_stdout or to_stderr.With no arg, passes if the block outputs to_stdout or to_stderr.
With no arg, passes if the block outputs to_stdout or to_stderr.
With no arg, passes if the block outputs to_stdout or to_stderr.

  

  
  
  
  
  
  
  
  

  
    With no arg, passes if the block outputs to_stdout or to_stderr.

  


      
        
  
  
  
  
  
  
  
  

  
    With no args, matches if any error is raised.With no args, matches if any error is raised.
With no args, matches if any error is raised.
With no args, matches if any error is raised.

  

  
  
  
  
  
  
  
  

  
    With no args, matches if any error is raised.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the target object responds to all of the names provided.Matches if the target object responds to all of the names provided.
Matches if the target object responds to all of the names provided.
Matches if the target object responds to all of the names provided.

  

  
  
  
  
  
  
  
  

  
    Matches if the target object responds to all of the names provided.

  


      
        
  
  
  
  
  
  
  
  

  
    :nocov:.:nocov:.
:nocov:.
:nocov:.

  

  
  
  
  
  
  
  
  

  
    :nocov:.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the submitted block returns true.Passes if the submitted block returns true.
Passes if the submitted block returns true.
Passes if the submitted block returns true.

  

  
  
  
  
  
  
  
  

  
    Passes if the submitted block returns true.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value starts with the expected value(s).Matches if the actual value starts with the expected value(s).
Matches if the actual value starts with the expected value(s).
Matches if the actual value starts with the expected value(s).

  

  
  
  
  
  
  
  
  

  
    Matches if the actual value starts with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no argument, matches if a proc throws any Symbol.Given no argument, matches if a proc throws any Symbol.
Given no argument, matches if a proc throws any Symbol.
Given no argument, matches if a proc throws any Symbol.

  

  
  
  
  
  
  
  
  

  
    Given no argument, matches if a proc throws any Symbol.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.
Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.
Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.

  

  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.

  


      
        
  
  
  
  
  
  
  
  

  
    Designed for use with methods that repeatedly yield (such as iterators).Designed for use with methods that repeatedly yield (such as iterators).
Designed for use with methods that repeatedly yield (such as iterators).
Designed for use with methods that repeatedly yield (such as iterators).

  

  
  
  
  
  
  
  
  

  
    Designed for use with methods that repeatedly yield (such as iterators).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).
Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).
Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

  

  
  
  
  
  
  
  
  

  
    Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields with no arguments.Passes if the method called in the expect block yields with no arguments.
Passes if the method called in the expect block yields with no arguments.
Passes if the method called in the expect block yields with no arguments.

  

  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields with no arguments.

  


      
    
      
        
  
  
  
  
  
  
  
  

  
    Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the provided matcher passes when checked against all elements of the collection.

  


      
        
  
  
  
  
  
  
  
  

  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively).

  


      
        
  
  
  
  
  
  
  
  

  
    passes if target.kind_of?(klass).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.kind_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.instance_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.between?(min, max).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is falsey (false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is nil.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is truthy (anything but false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected +/- delta.

  


      
        
  
  
  
  
  
  
  
  

  
    Applied to a proc, specifies that its execution will cause some value to change.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual contains all of the expected regardless of order.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual covers expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value ends with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.eql?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.equal?(expected) (object identity).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.exist? or actual.exists?.

  


      
        
  
  
  
  
  
  
  
  

  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual's attribute values match the expected attributes hash.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual includes expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.

  


      
        
  
  
  
  
  
  
  
  

  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.

  


      
        
  
  
  
  
  
  
  
  

  
    With no arg, passes if the block outputs to_stdout or to_stderr.

  


      
        
  
  
  
  
  
  
  
  

  
    With no args, matches if any error is raised.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the target object responds to all of the names provided.

  


      
        
  
  
  
  
  
  
  
  

  
    :nocov:.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the submitted block returns true.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value starts with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no argument, matches if a proc throws any Symbol.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.

  


      
        
  
  
  
  
  
  
  
  

  
    Designed for use with methods that repeatedly yield (such as iterators).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields with no arguments.

  


      
    
  


  
  
  
  
  
  
  
  
  Methods included from DSLMethods included from DSL
  alias_matcher, define, define_negated_matcheralias_matcher, define, define_negated_matcher

  Dynamic Method HandlingDynamic Method Handling
  
    This class handles dynamic methods through the method_missingmethod_missing method
    
  
    This class handles dynamic methods through the method_missing method
    
  
  
    
  
  
    
      


956
957
958
959
960
961
962
963
964
965


956
957
958
959
960
961
962
963
964
965
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956# File 'lib/rspec/matchers.rb', line 956

defdef method_missingmethod_missing((methodmethod,, **argsargs,, &&blockblock))
  casecase methodmethod..to_sto_s
  whenwhen BE_PREDICATE_REGEXBE_PREDICATE_REGEX
    BuiltInBuiltIn::::BePredicateBePredicate..newnew((methodmethod,, **argsargs,, &&blockblock))
  whenwhen HAS_REGEXHAS_REGEX
    BuiltInBuiltIn::::HasHas..newnew((methodmethod,, **argsargs,, &&blockblock))
  elseelse
    supersuper
  endend
endend# File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  

  
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  


  
  
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  


  

  Dynamic Method Handling
  
    This class handles dynamic methods through the method_missing method
    
  
  
    
  
  
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  


  



  
    Class Method DetailsClass Method Details

    
      
  
  
    Extended from RSpec::Matchers::DSL#alias_matcher.Extended from RSpec::Matchers::DSL#alias_matcher.


  
    Extended from RSpec::Matchers::DSL#alias_matcher.


  

  
    Extended from RSpec::Matchers::DSL#alias_matcher.


  


  


  


  
    
      


250
251
252


250
251
252
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250# File 'lib/rspec/matchers.rb', line 250

defdef selfself..alias_matcheralias_matcher((**argsargs,, &&blockblock))
  supersuper((**argsargs,, &&blockblock))
endend# File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  

  
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  


  
  
    Extended from RSpec::Matchers::DSL#alias_matcher.


  


  


  
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .   This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.Used by rspec-core to clear the state used to generate descriptions after an example.


  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.


  

  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.


  


  


  


  
    
      


11
12
13
14


11
12
13
14
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11# File 'lib/rspec/matchers/generated_descriptions.rb', line 11

defdef selfself..clear_generated_descriptionclear_generated_description
  selfself..last_matcherlast_matcher == nilnil
  selfself..last_expectation_handlerlast_expectation_handler == nilnil
endend# File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  

  
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  


  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.


  


  


  
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  


    
      
  
  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  

  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  


  
Returns:Returns:

  
    
      
      
        (RSpec::Expectations::ConfigurationRSpec::Expectations::Configuration)(RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration objectthe configuration object
the configuration object

      
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  

  
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  



  
Returns:

  
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  



  
    
      


946
947
948


946
947
948
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946# File 'lib/rspec/matchers.rb', line 946

defdef selfself..configurationconfiguration
  ExpectationsExpectations..configurationconfiguration
endend# File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  

  
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  


  
  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  


  
Returns:

  
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  



  
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define.Extended from RSpec::Matchers::DSL#define.


  
    Extended from RSpec::Matchers::DSL#define.


  

  
    Extended from RSpec::Matchers::DSL#define.


  


  


  


  
    
      






    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257# File 'lib/rspec/matchers.rb', line 257

# File 'lib/rspec/matchers.rb', line 257


    
      # File 'lib/rspec/matchers.rb', line 257


    
  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257


    
  

  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257


    
  


  
  
    Extended from RSpec::Matchers::DSL#define.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257


    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.Extended from RSpec::Matchers::DSL#define_negated_matcher.


  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.


  

  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.


  


  


  


  
    
      






    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260# File 'lib/rspec/matchers.rb', line 260

# File 'lib/rspec/matchers.rb', line 260


    
      # File 'lib/rspec/matchers.rb', line 260


    
  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260


    
  

  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260


    
  


  
  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260


    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .   This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  

  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  


  


  


  
    
      


19
20
21
22


19
20
21
22
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19# File 'lib/rspec/matchers/generated_descriptions.rb', line 19

defdef selfself..generated_descriptiongenerated_description
  returnreturn nilnil ifif last_expectation_handlerlast_expectation_handler..nil?nil?
  ""#{#{last_expectation_handlerlast_expectation_handler..verbverb}}  #{#{last_descriptionlast_description}}"""#{last_expectation_handler.verb} #{last_description}"
endend# File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  

  
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  


  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  


  


  
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  


    
  
    Class Method Details

    
      
  
  
    Extended from RSpec::Matchers::DSL#alias_matcher.


  


  


  
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.


  


  


  
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  


    
      
  
  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  


  
Returns:

  
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  



  
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257


    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260


    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  


  


  
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  


    
  

  
    Instance Method DetailsInstance Method Details

    
      
  
  
    
  
    Note:Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.
The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  
    
  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  

  
    
  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  


  
  
    Examples:Examples:
    
      
      aggregate_failuresaggregate_failures((""verifying responseverifying response"""verifying response")) dodo
  expectexpect((responseresponse..statusstatus))..toto eqeq((200200))
  expectexpect((responseresponse..headersheaders))..toto includeinclude((""Content-TypeContent-Type"""Content-Type" =>=> ""text/plaintext/plain"""text/plain"))
  expectexpect((responseresponse..bodybody))..toto includeinclude((""SuccessSuccess"""Success"))
endendaggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
endaggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
    Examples:
    
      
      aggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
Parameters:Parameters:

  
    
      
        labellabel
      
      
        (StringString)(String)
      
      
        (defaults to: nilnil)(defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.label for this aggregation block, which will be included in the aggregated exception message.
label for this aggregation block, which will be included in the aggregated exception message.

      
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadatametadata
      
      
        (HashHash)(Hash)
      
      
        (defaults to: {}{})(defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.
additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  

  
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  


Yields:Yields:

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.
Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

Raises:Raises:

  
    
      
      
        (Expectations::MultipleExpectationsNotMetErrorExpectations::MultipleExpectationsNotMetError)(Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.raised when multiple expectations fail.
raised when multiple expectations fail.

      
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetErrorExpectations::ExpectationNotMetError)(Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.raised when a single expectation fails.
raised when a single expectation fails.

      
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (ExceptionException)(Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.other sorts of exceptions will be raised as normal.
other sorts of exceptions will be raised as normal.

      
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  

  
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  



  
  
    Examples:
    
      
      aggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
Parameters:

  
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  


Yields:

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

Raises:

  
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  



  
    
      


305
306
307


305
306
307
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305# File 'lib/rspec/matchers.rb', line 305

defdef aggregate_failuresaggregate_failures((labellabel==nilnil,, metadatametadata=={{}},, &&blockblock))
  ExpectationsExpectations::::FailureAggregatorFailureAggregator..newnew((labellabel,, metadatametadata))..aggregateaggregate((&&blockblock))
endend# File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  

  
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  


  
  
    
  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  


  
  
    Examples:
    
      
      aggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
Parameters:

  
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  


Yields:

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

Raises:

  
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  



  
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  


    
      
  
  
    
  
    Note:Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).
The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:Note:
    You can also use this with compound matchers as well.You can also use this with compound matchers as well.
You can also use this with compound matchers as well.

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.Passes if the provided matcher passes when checked against all elements of the collection.


  
    
  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.


  

  
    
  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.


  


  
  
    Examples:Examples:
    
      
      expectexpect(([[11,, 33,, 55]]))..toto allall be_oddbe_odd
expectexpect(([[11,, 33,, 66]]))..toto allall be_oddbe_odd # fails# failsexpect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # failsexpect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expectexpect(([[11,, 33,, 55]]))..toto allall(( be_oddbe_odd..andand be_anbe_an((IntegerInteger)) ))expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  
    Examples:
    
      
      expect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  



  
  
    Examples:
    
      
      expect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  



  
    
      


662
663
664


662
663
664
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662# File 'lib/rspec/matchers.rb', line 662

defdef allall((expectedexpected))
  BuiltInBuiltIn::::AllAll..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  

  
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  


  
  
    
  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.


  


  
  
    Examples:
    
      
      expect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  



  
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  


    
      
  
  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  

  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  


  
  
    Examples:Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  
    Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  



  
  
    Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  



  
    
      


349
350
351


349
350
351
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349# File 'lib/rspec/matchers.rb', line 349

defdef bebe((**argsargs))
  argsargs..empty?empty? ?? MatchersMatchers::::BuiltInBuiltIn::::BeBe..newnew :: equalequal((**argsargs))
endend# File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  

  
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  


  
  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  


  
  
    Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  



  
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  


    
      
  
  
    passes if target.kind_of?(klass).passes if target.kind_of?(klass).


  
    passes if target.kind_of?(klass).


  

  
    passes if target.kind_of?(klass).


  


  


  


  
    
      


355
356
357


355
356
357
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355# File 'lib/rspec/matchers.rb', line 355

defdef be_abe_a((klassklass))
  be_a_kind_ofbe_a_kind_of((klassklass))
endend# File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  

  
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  


  
  
    passes if target.kind_of?(klass).


  


  


  
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  


    
      
  
  
    Passes if actual.kind_of?(expected).Passes if actual.kind_of?(expected).


  
    Passes if actual.kind_of?(expected).


  

  
    Passes if actual.kind_of?(expected).


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto     be_a_kind_ofbe_a_kind_of((IntegerInteger))
expectexpect((55))..toto     be_a_kind_ofbe_a_kind_of((NumericNumeric))
expectexpect((55))..not_tonot_to be_a_kind_ofbe_a_kind_of((FloatFloat))expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  
    Examples:
    
      
      expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  



  
  
    Examples:
    
      
      expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  



  
    
      


378
379
380


378
379
380
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378# File 'lib/rspec/matchers.rb', line 378

defdef be_a_kind_ofbe_a_kind_of((expectedexpected))
  BuiltInBuiltIn::::BeAKindOfBeAKindOf..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  

  
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  


  
  
    Passes if actual.kind_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  



  
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.instance_of?(expected).Passes if actual.instance_of?(expected).


  
    Passes if actual.instance_of?(expected).


  

  
    Passes if actual.instance_of?(expected).


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto     be_an_instance_ofbe_an_instance_of((IntegerInteger))
expectexpect((55))..not_tonot_to be_an_instance_ofbe_an_instance_of((NumericNumeric))
expectexpect((55))..not_tonot_to be_an_instance_ofbe_an_instance_of((FloatFloat))expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  
    Examples:
    
      
      expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  



  
  
    Examples:
    
      
      expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  



  
    
      


366
367
368


366
367
368
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366# File 'lib/rspec/matchers.rb', line 366

defdef be_an_instance_ofbe_an_instance_of((expectedexpected))
  BuiltInBuiltIn::::BeAnInstanceOfBeAnInstanceOf..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  

  
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  


  
  
    Passes if actual.instance_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  



  
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  

  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto      be_betweenbe_between((11,, 1010))
expectexpect((1111))..not_tonot_to be_betweenbe_between((11,, 1010))
expectexpect((1010))..not_tonot_to be_betweenbe_between((11,, 1010))..exclusiveexclusiveexpect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusiveexpect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  
    Examples:
    
      
      expect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  



  
  
    Examples:
    
      
      expect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  



  
    
      


395
396
397


395
396
397
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395# File 'lib/rspec/matchers.rb', line 395

defdef be_betweenbe_between((minmin,, maxmax))
  BuiltInBuiltIn::::BeBetweenBeBetween..newnew((minmin,, maxmax))
endend# File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  

  
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  


  
  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  


  
  
    Examples:
    
      
      expect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  



  
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  


    
      
  
  
    Passes if actual is falsey (false or nil).Passes if actual is falsey (false or nil).


  
    Passes if actual is falsey (false or nil).


  

  
    Passes if actual is falsey (false or nil).


  


  


  


  
    
      


316
317
318


316
317
318
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316# File 'lib/rspec/matchers.rb', line 316

defdef be_falseybe_falsey
  BuiltInBuiltIn::::BeFalseyBeFalsey..newnew
endend# File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  

  
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  


  
  
    Passes if actual is falsey (false or nil).


  


  


  
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  


    
      
  
  
    Passes if actual is nil.Passes if actual is nil.


  
    Passes if actual is nil.


  

  
    Passes if actual is nil.


  


  


  


  
    
      


324
325
326


324
325
326
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324# File 'lib/rspec/matchers.rb', line 324

defdef be_nilbe_nil
  BuiltInBuiltIn::::BeNilBeNil..newnew
endend# File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  

  
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  


  
  
    Passes if actual is nil.


  


  


  
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  


    
      
  
  
    Passes if actual is truthy (anything but false or nil).Passes if actual is truthy (anything but false or nil).


  
    Passes if actual is truthy (anything but false or nil).


  

  
    Passes if actual is truthy (anything but false or nil).


  


  


  


  
    
      


310
311
312


310
311
312
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310# File 'lib/rspec/matchers.rb', line 310

defdef be_truthybe_truthy
  BuiltInBuiltIn::::BeTruthyBeTruthy..newnew
endend# File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  

  
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  


  
  
    Passes if actual is truthy (anything but false or nil).


  


  


  
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  


    
      
  
  
    Passes if actual == expected +/- delta.Passes if actual == expected +/- delta.


  
    Passes if actual == expected +/- delta.


  

  
    Passes if actual == expected +/- delta.


  


  
  
    Examples:Examples:
    
      
      expectexpect((resultresult))..toto     be_withinbe_within((0.50.5))..ofof((3.03.0))
expectexpect((resultresult))..not_tonot_to be_withinbe_within((0.50.5))..ofof((3.03.0))expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  
    Examples:
    
      
      expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  



  
  
    Examples:
    
      
      expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  



  
    
      


405
406
407


405
406
407
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405# File 'lib/rspec/matchers.rb', line 405

defdef be_withinbe_within((deltadelta))
  BuiltInBuiltIn::::BeWithinBeWithin..newnew((deltadelta))
endend# File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  

  
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  


  
  
    Passes if actual == expected +/- delta.


  


  
  
    Examples:
    
      
      expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  



  
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  


    
      
  
  
    Applied to a proc, specifies that its execution will cause some value to change.Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.You can chain any of the following off of the end to specify details about the change:.


fromfromfrom
tototo

from
to


or any one of:.or any one of:.


bybyby
by_at_leastby_at_leastby_at_least
by_at_mostby_at_mostby_at_most

by
by_at_least
by_at_most


== Notes.== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  
    Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.


from
to


or any one of:.


by
by_at_least
by_at_most


== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  

  
    Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.


from
to


or any one of:.


by
by_at_least
by_at_most


== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{
  teamteam..add_playeradd_player((playerplayer))
}}..toto changechange((rosterroster,, :count:count))

expectexpect {{
  teamteam..add_playeradd_player((playerplayer))
}}..toto changechange((rosterroster,, :count:count))..byby((11))

expectexpect {{
  teamteam..add_playeradd_player((playerplayer))
}}..toto changechange((rosterroster,, :count:count))..by_at_leastby_at_least((11))

expectexpect {{
  teamteam..add_playeradd_player((playerplayer))
}}..toto changechange((rosterroster,, :count:count))..by_at_mostby_at_most((11))

stringstring == ""stringstring"""string"
expectexpect {{
  stringstring..reverse!reverse!
}}..toto changechange {{ stringstring }}..fromfrom((""stringstring"""string"))..toto((""gnirtsgnirts"""gnirts"))

stringstring == ""stringstring"""string"
expectexpect {{
  stringstring
}}..not_tonot_to changechange {{ stringstring }}..fromfrom((""stringstring"""string"))

expectexpect {{
  personperson..happy_birthdayhappy_birthday
}}..toto changechange((personperson,, :birthday:birthday))..fromfrom((3232))..toto((3333))

expectexpect {{
  employeeemployee..develop_great_new_social_networking_appdevelop_great_new_social_networking_app
}}..toto changechange((employeeemployee,, :title:title))..fromfrom((""Mail ClerkMail Clerk"""Mail Clerk"))..toto((""CEOCEO"""CEO"))

expectexpect {{
  doctordoctor..leave_officeleave_office
}}..toto changechange((doctordoctor,, :sign:sign))..fromfrom((//is inis in///is in/))..toto((//is outis out///is out/))

useruser == UserUser..newnew((:type:type =>=> ""adminadmin"""admin"))
expectexpect {{
  useruser..symbolize_typesymbolize_type
}}..toto changechange((useruser,, :type:type))..fromfrom((StringString))..toto((SymbolSymbol))expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
    Examples:
    
      
      expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
Parameters:Parameters:

  
    
      
        receiverreceiver
      
      
        (ObjectObject)(Object)
      
      
        (defaults to: nilnil)(defaults to: nil)
      
      
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        messagemessage
      
      
        (SymbolSymbol)(Symbol)
      
      
        (defaults to: nilnil)(defaults to: nil)
      
      
        —
        the message to send the receiverthe message to send the receiver
the message to send the receiver

      
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  

  
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  




  
  
    Examples:
    
      
      expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
Parameters:

  
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  




  
    
      


492
493
494


492
493
494
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492# File 'lib/rspec/matchers.rb', line 492

defdef changechange((receiverreceiver==nilnil,, messagemessage==nilnil,, &&blockblock))
  BuiltInBuiltIn::::ChangeChange..newnew((receiverreceiver,, messagemessage,, &&blockblock))
endend# File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  

  
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  


  
  
    Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.


from
to


or any one of:.


by
by_at_least
by_at_most


== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  


  
  
    Examples:
    
      
      expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
Parameters:

  
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  




  
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  


    
      
  
  
    
  
    Note:Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.This is also available using the =~ operator with should, but =~ is not supported with expect.
This is also available using the =~ operator with should, but =~ is not supported with expect.

  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  
    
  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  

  
    
  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:Examples:
    
      
      expectexpect(([[11,, 22,, 33]]))..toto contain_exactlycontain_exactly((11,, 22,, 33))
expectexpect(([[11,, 22,, 33]]))..toto contain_exactlycontain_exactly((11,, 33,, 22))expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  
    Examples:
    
      
      expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  


  See Also:See Also:
  
    
      #match_array#match_array
    
  
    
      #match_array
    
  


  
  
    Examples:
    
      
      expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  


  See Also:
  
    
      #match_array
    
  


  
    
      


510
511
512


510
511
512
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510# File 'lib/rspec/matchers.rb', line 510

defdef contain_exactlycontain_exactly((**itemsitems))
  BuiltInBuiltIn::::ContainExactlyContainExactly..newnew((itemsitems))
endend# File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  

  
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  


  
  
    
  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  


  See Also:
  
    
      #match_array
    
  


  
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  


    
      
  
  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 onlyWarning:: Ruby >= 1.9 only


  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 only


  

  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 only


  


  
  
    Examples:Examples:
    
      
      expectexpect((11....1010))..toto     covercover((55))
expectexpect((11....1010))..toto     covercover((44,, 66))
expectexpect((11....1010))..toto     covercover((44,, 66,, 1111)) # fails
# fails
expectexpect((11....1010))..not_tonot_to covercover((1111))
expectexpect((11....1010))..not_tonot_to covercover((55))        # fails# failsexpect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # failsexpect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  
    Examples:
    
      
      expect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  



  
  
    Examples:
    
      
      expect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  



  
    
      


528
529
530


528
529
530
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528# File 'lib/rspec/matchers.rb', line 528

defdef covercover((**valuesvalues))
  BuiltInBuiltIn::::CoverCover..newnew((**valuesvalues))
endend# File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  

  
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  


  
  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 only


  


  
  
    Examples:
    
      
      expect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  



  
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  


    
      
  
  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  

  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  


  
  
    Examples:Examples:
    
      
      expectexpect((""this stringthis string"""this string"))..toto   end_withend_with ""stringstring"""string"
expectexpect(([[00,, 11,, 22,, 33,, 44]]))..toto end_withend_with 44
expectexpect(([[00,, 22,, 33,, 44,, 44]]))..toto end_withend_with 33,, 44expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  
    Examples:
    
      
      expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  



  
  
    Examples:
    
      
      expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  



  
    
      


543
544
545


543
544
545
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543# File 'lib/rspec/matchers.rb', line 543

defdef end_withend_with((**expectedexpected))
  BuiltInBuiltIn::::EndWithEndWith..newnew((**expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  

  
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  


  
  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  



  
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  


    
      
  
  
    Passes if actual == expected.Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  
    Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  

  
    Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto     eqeq((55))
expectexpect((55))..not_tonot_to eqeq((33))expect(5).to     eq(5)
expect(5).not_to eq(3)expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  
    Examples:
    
      
      expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  



  
  
    Examples:
    
      
      expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  



  
    
      


558
559
560


558
559
560
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558# File 'lib/rspec/matchers.rb', line 558

defdef eqeq((expectedexpected))
  BuiltInBuiltIn::::EqEq..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  

  
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  


  
  
    Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  



  
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  


    
      
  
  
    Passes if actual.eql?(expected).Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  
    Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  

  
    Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto     eqleql((55))
expectexpect((55))..not_tonot_to eqleql((33))expect(5).to     eql(5)
expect(5).not_to eql(3)expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  
    Examples:
    
      
      expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  



  
  
    Examples:
    
      
      expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  



  
    
      


572
573
574


572
573
574
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572# File 'lib/rspec/matchers.rb', line 572

defdef eqleql((expectedexpected))
  BuiltInBuiltIn::::EqlEql..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  

  
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  


  
  
    Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  



  
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  


    
      
  
  
    Passes if actual.equal?(expected) (object identity).Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  
    Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  

  
    Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto       equalequal((55))   # Integers are equal
# Integers are equal
expectexpect((""55"""5"))..not_tonot_to equalequal((""55"""5")) # Strings that look the same are not the same object# Strings that look the same are not the same objectexpect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same objectexpect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  
    Examples:
    
      
      expect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  



  
  
    Examples:
    
      
      expect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  



  
    
      


586
587
588


586
587
588
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586# File 'lib/rspec/matchers.rb', line 586

defdef equalequal((expectedexpected))
  BuiltInBuiltIn::::EqualEqual..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  

  
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  


  
  
    Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  



  
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  


    
      
  
  
    Passes if actual.exist? or actual.exists?.Passes if actual.exist? or actual.exists?.


  
    Passes if actual.exist? or actual.exists?.


  

  
    Passes if actual.exist? or actual.exists?.


  


  
  
    Examples:Examples:
    
      
      expectexpect((FileFile))..toto existexist((""path/to/filepath/to/file"""path/to/file"))expect(File).to exist("path/to/file")expect(File).to exist("path/to/file")
    
  
    Examples:
    
      
      expect(File).to exist("path/to/file")
    
  



  
  
    Examples:
    
      
      expect(File).to exist("path/to/file")
    
  



  
    
      


596
597
598


596
597
598
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596# File 'lib/rspec/matchers.rb', line 596

defdef existexist((**argsargs))
  BuiltInBuiltIn::::ExistExist..newnew((**argsargs))
endend# File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  

  
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  


  
  
    Passes if actual.exist? or actual.exists?.


  


  
  
    Examples:
    
      
      expect(File).to exist("path/to/file")
    
  



  
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  


    
      
  
  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  

  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  


  
  
    Examples:Examples:
    
      
      expectexpect((actualactual))..toto eqeq((expectedexpected))
expectexpect((actualactual))..not_tonot_to eqeq((expectedexpected))expect(actual).to eq(expected)
expect(actual).not_to eq(expected)expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  
    Examples:
    
      
      expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  

Returns:Returns:

  
    
      
      
        (Expectations::ExpectationTargetExpectations::ExpectationTarget)(Expectations::ExpectationTarget)
      
      
      
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  

  
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  


  See Also:See Also:
  
    
      Expectations::ExpectationTarget::InstanceMethods#toExpectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_toExpectations::ExpectationTarget::InstanceMethods#not_to
    
  
    
      Expectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_to
    
  


  
  
    Examples:
    
      
      expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  

Returns:

  
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  


  See Also:
  
    
      Expectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_to
    
  


  
    
      






    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263# File 'lib/rspec/matchers.rb', line 263

# File 'lib/rspec/matchers.rb', line 263


    
      # File 'lib/rspec/matchers.rb', line 263


    
  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263


    
  

  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263


    
  


  
  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  


  
  
    Examples:
    
      
      expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  

Returns:

  
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  


  See Also:
  
    
      Expectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_to
    
  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263


    
  


    
      
  
  
    
  
    Note:Note:
    It will fail if actual doesn't respond to any of the expected attributes.It will fail if actual doesn't respond to any of the expected attributes.
It will fail if actual doesn't respond to any of the expected attributes.

  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  
    
  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  

  
    
  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  


  
  
    Examples:Examples:
    
      
      PersonPerson == StructStruct..newnew((:name:name,, :age:age))
personperson == PersonPerson..newnew((""BobBob"""Bob",, 3232))

expectexpect((personperson))..toto have_attributeshave_attributes((:name:name =>=> ""BobBob"""Bob",, :age:age =>=> 3232))
expectexpect((personperson))..toto have_attributeshave_attributes((:name:name =>=> a_string_starting_witha_string_starting_with((""BB"""B")),, :age:age =>=> ((a_valuea_value >> 3030)) ))Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expectexpect((personperson))..toto have_attributeshave_attributes((:color:color =>=> ""redred"""red"))expect(person).to have_attributes(:color => "red")expect(person).to have_attributes(:color => "red")
    
  
    Examples:
    
      
      Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expect(person).to have_attributes(:color => "red")
    
  



  
  
    Examples:
    
      
      Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expect(person).to have_attributes(:color => "red")
    
  



  
    
      


616
617
618


616
617
618
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616# File 'lib/rspec/matchers.rb', line 616

defdef have_attributeshave_attributes((expectedexpected))
  BuiltInBuiltIn::::HaveAttributesHaveAttributes..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  

  
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  


  
  
    
  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  


  
  
    Examples:
    
      
      Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expect(person).to have_attributes(:color => "red")
    
  



  
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  


    
      
  
  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  

  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:Examples:
    
      
      expectexpect(([[11,,22,,33]]))..toto      includeinclude((33))
expectexpect(([[11,,22,,33]]))..toto      includeinclude((22,,33))
expectexpect(([[11,,22,,33]]))..toto      includeinclude((22,,33,,44)) # fails
# fails
expectexpect(([[11,,22,,33]]))..not_tonot_to  includeinclude((44))
expectexpect((""spreadspread"""spread"))..toto     includeinclude((""readread"""read"))
expectexpect((""spreadspread"""spread"))..not_tonot_to includeinclude((""redred"""red"))
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..toto includeinclude((:a:a))
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..toto includeinclude((:a:a,, :b:b))
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..toto includeinclude((:a:a =>=> 11))
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..toto includeinclude((:b:b =>=> 22,, :a:a =>=> 11))
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..toto includeinclude((:c:c)) # fails
# fails
expectexpect((:a:a =>=> 11,, :b:b =>=> 22))..not_tonot_to includeinclude((:a:a =>=> 22))expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  
    Examples:
    
      
      expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  



  
  
    Examples:
    
      
      expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  



  
    
      


639
640
641


639
640
641
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639# File 'lib/rspec/matchers.rb', line 639

defdef includeinclude((**expectedexpected))
  BuiltInBuiltIn::::IncludeInclude..newnew((**expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  

  
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  


  
  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  



  
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  


    
      
  
  
    
  
    Note:Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.
The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  
    
  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  

  
    
  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  


  
  
    Examples:Examples:
    
      
      expectexpect((emailemail))..toto matchmatch((//^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i/i/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i))
expectexpect((emailemail))..toto matchmatch((""@example.com@example.com"""@example.com"))expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hashhash == {{
  :a:a =>=> {{
    :b:b =>=> [[""foofoo"""foo",, 55]],,
    :c:c =>=> {{ :d:d =>=> 2.052.05 }}
  }}
}}

expectexpect((hashhash))..toto matchmatch((
  :a:a =>=> {{
    :b:b =>=> a_collection_containing_exactlya_collection_containing_exactly((
      a_string_starting_witha_string_starting_with((""ff"""f")),,
      an_instance_ofan_instance_of((IntegerInteger))
    )),,
    :c:c =>=> {{ :d:d =>=> ((a_valuea_value << 33)) }}
  }}
))hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  
    Examples:
    
      
      expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  



  
  
    Examples:
    
      
      expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  



  
    
      


697
698
699


697
698
699
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697# File 'lib/rspec/matchers.rb', line 697

defdef matchmatch((expectedexpected))
  BuiltInBuiltIn::::MatchMatch..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  

  
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  


  
  
    
  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  


  
  
    Examples:
    
      
      expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  



  
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  


    
      
  
  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  

  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  


  
  
    Examples:Examples:
    
      
      expectexpect((resultsresults))..toto contain_exactlycontain_exactly((11,, 22))
# is identical to:
# is identical to:
expectexpect((resultsresults))..toto match_arraymatch_array(([[11,, 22]]))expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  
    Examples:
    
      
      expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  


  See Also:See Also:
  
    
      #contain_exactly#contain_exactly
    
  
    
      #contain_exactly
    
  


  
  
    Examples:
    
      
      expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  


  See Also:
  
    
      #contain_exactly
    
  


  
    
      


715
716
717


715
716
717
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715# File 'lib/rspec/matchers.rb', line 715

defdef match_arraymatch_array((itemsitems))
  contain_exactlycontain_exactly((**itemsitems))
endend# File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  

  
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  


  
  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  


  
  
    Examples:
    
      
      expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  


  See Also:
  
    
      #contain_exactly
    
  


  
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  


    
      
  
  
    
  
    Note:Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.
to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.
to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  
    
  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  

  
    
  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ printprint ''foofoo'''foo' }}..toto outputoutput..to_stdoutto_stdout
expectexpect {{ printprint ''foofoo'''foo' }}..toto outputoutput((''foofoo'''foo'))..to_stdoutto_stdout
expectexpect {{ printprint ''foofoo'''foo' }}..toto outputoutput((//foofoo///foo/))..to_stdoutto_stdout

expectexpect {{ do_somethingdo_something }}..to_notto_not outputoutput..to_stdoutto_stdout

expectexpect {{ warnwarn((''foofoo'''foo')) }}..toto outputoutput..to_stderrto_stderr
expectexpect {{ warnwarn((''foofoo'''foo')) }}..toto outputoutput((''foofoo'''foo'))..to_stderrto_stderr
expectexpect {{ warnwarn((''foofoo'''foo')) }}..toto outputoutput((//foofoo///foo/))..to_stderrto_stderr

expectexpect {{ do_somethingdo_something }}..to_notto_not outputoutput..to_stderrto_stderr

expectexpect {{ systemsystem((''echo fooecho foo'''echo foo')) }}..toto outputoutput((""foo\nfoo\n"""foo\n"))..to_stdout_from_any_processto_stdout_from_any_process
expectexpect {{ systemsystem((''echo fooecho foo'''echo foo',, out:out: :err:err)) }}..toto outputoutput((""foo\nfoo\n"""foo\n"))..to_stderr_from_any_processto_stderr_from_any_processexpect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_processexpect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  
    Examples:
    
      
      expect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  



  
  
    Examples:
    
      
      expect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  



  
    
      


749
750
751


749
750
751
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749# File 'lib/rspec/matchers.rb', line 749

defdef outputoutput((expectedexpected==nilnil))
  BuiltInBuiltIn::::OutputOutput..newnew((expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  

  
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  


  
  
    
  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  


  
  
    Examples:
    
      
      expect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  



  
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  


    
      
  
  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  

  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ do_something_riskydo_something_risky }}..toto raise_errorraise_error
expectexpect {{ do_something_riskydo_something_risky }}..toto raise_errorraise_error((PoorRiskDecisionErrorPoorRiskDecisionError))
expectexpect {{ do_something_riskydo_something_risky }}..toto raise_errorraise_error((PoorRiskDecisionErrorPoorRiskDecisionError)) {{ ||errorerror|| expectexpect((errorerror..datadata))..toto eqeq 4242 }}
expectexpect {{ do_something_riskydo_something_risky }}..toto raise_errorraise_error((PoorRiskDecisionErrorPoorRiskDecisionError,, ""that was too riskythat was too risky"""that was too risky"))
expectexpect {{ do_something_riskydo_something_risky }}..toto raise_errorraise_error((PoorRiskDecisionErrorPoorRiskDecisionError,, //oo rioo ri///oo ri/))

expectexpect {{ do_something_riskydo_something_risky }}..not_tonot_to raise_errorraise_errorexpect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_errorexpect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  
    Examples:
    
      
      expect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  



  
  
    Examples:
    
      
      expect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  



  
    
      


768
769
770


768
769
770
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768# File 'lib/rspec/matchers.rb', line 768

defdef raise_errorraise_error((errorerror==nilnil,, messagemessage==nilnil,, &&blockblock))
  BuiltInBuiltIn::::RaiseErrorRaiseError..newnew((errorerror,, messagemessage,, &&blockblock))
endend# File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  

  
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  


  
  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  



  
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  


    
      
  
  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  

  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  


  
  
    Examples:Examples:
    
      
      expectexpect((""stringstring"""string"))..toto respond_torespond_to((:length:length))expect("string").to respond_to(:length)expect("string").to respond_to(:length)
    
  
    Examples:
    
      
      expect("string").to respond_to(:length)
    
  



  
  
    Examples:
    
      
      expect("string").to respond_to(:length)
    
  



  
    
      


787
788
789


787
788
789
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787# File 'lib/rspec/matchers.rb', line 787

defdef respond_torespond_to((**namesnames))
  BuiltInBuiltIn::::RespondToRespondTo..newnew((**namesnames))
endend# File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  

  
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  


  
  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  


  
  
    Examples:
    
      
      expect("string").to respond_to(:length)
    
  



  
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  


    
      
  
  
    :nocov:.:nocov:.


  
    :nocov:.


  

  
    :nocov:.


  


  
Returns:Returns:

  
    
      
      
        (BooleanBoolean)(Boolean)
      
      
      
    
      
      
        (Boolean)
      
      
      
    
  

  
    
      
      
        (Boolean)
      
      
      
    
  



  
Returns:

  
    
      
      
        (Boolean)
      
      
      
    
  



  
    
      


973
974
975
976


973
974
975
976
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973# File 'lib/rspec/matchers.rb', line 973

defdef respond_to?respond_to?((methodmethod,, **))
  methodmethod == methodmethod..to_sto_s
  methodmethod =~=~ DYNAMIC_MATCHER_REGEXDYNAMIC_MATCHER_REGEX |||| supersuper
endend# File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  

  
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  


  
  
    :nocov:.


  


  
Returns:

  
    
      
      
        (Boolean)
      
      
      
    
  



  
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  


    
      
  
  
    Passes if the submitted block returns true. Yields target to the block.Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  
    Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  

  
    Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  


  
  
    Examples:Examples:
    
      
      expectexpect((55))..toto satisfysatisfy {{ ||nn|| nn >> 33 }}
expectexpect((55))..toto satisfysatisfy((""be greater than 3be greater than 3"""be greater than 3")) {{ ||nn|| nn >> 33 }}expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
    Examples:
    
      
      expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
Parameters:Parameters:

  
    
      
        descriptiondescription
      
      
        (StringString)(String)
      
      
        (defaults to: nilnil)(defaults to: nil)
      
      
        —
        optional description to be used for this matcher.optional description to be used for this matcher.
optional description to be used for this matcher.

      
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  

  
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  




  
  
    Examples:
    
      
      expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
Parameters:

  
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  




  
    
      


808
809
810


808
809
810
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808# File 'lib/rspec/matchers.rb', line 808

defdef satisfysatisfy((descriptiondescription==nilnil,, &&blockblock))
  BuiltInBuiltIn::::SatisfySatisfy..newnew((descriptiondescription,, &&blockblock))
endend# File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  

  
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  


  
  
    Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  


  
  
    Examples:
    
      
      expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
Parameters:

  
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  




  
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  


    
      
  
  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  

  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  


  
  
    Examples:Examples:
    
      
      expectexpect((""this stringthis string"""this string"))..toto   start_withstart_with ""this sthis s"""this s"
expectexpect(([[00,, 11,, 22,, 33,, 44]]))..toto start_withstart_with 00
expectexpect(([[00,, 22,, 33,, 44,, 44]]))..toto start_withstart_with 00,, 11expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  
    Examples:
    
      
      expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  



  
  
    Examples:
    
      
      expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  



  
    
      


823
824
825


823
824
825
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823# File 'lib/rspec/matchers.rb', line 823

defdef start_withstart_with((**expectedexpected))
  BuiltInBuiltIn::::StartWithStartWith..newnew((**expectedexpected))
endend# File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  

  
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  


  
  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  



  
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  


    
      
  
  
    Given no argument, matches if a proc throws any Symbol.Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  
    Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  

  
    Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ do_something_riskydo_something_risky }}..toto throw_symbolthrow_symbol
expectexpect {{ do_something_riskydo_something_risky }}..toto throw_symbolthrow_symbol((:that_was_risky:that_was_risky))
expectexpect {{ do_something_riskydo_something_risky }}..toto throw_symbolthrow_symbol((:that_was_risky:that_was_risky,, ''culpritculprit'''culprit'))

expectexpect {{ do_something_riskydo_something_risky }}..not_tonot_to throw_symbolthrow_symbol
expectexpect {{ do_something_riskydo_something_risky }}..not_tonot_to throw_symbolthrow_symbol((:that_was_risky:that_was_risky))
expectexpect {{ do_something_riskydo_something_risky }}..not_tonot_to throw_symbolthrow_symbol((:that_was_risky:that_was_risky,, ''culpritculprit'''culprit'))expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  
    Examples:
    
      
      expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  



  
  
    Examples:
    
      
      expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  



  
    
      


845
846
847


845
846
847
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845# File 'lib/rspec/matchers.rb', line 845

defdef throw_symbolthrow_symbol((expected_symbolexpected_symbol==nilnil,, expected_argexpected_arg==nilnil))
  BuiltInBuiltIn::::ThrowSymbolThrowSymbol..newnew((expected_symbolexpected_symbol,, expected_argexpected_arg))
endend# File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  

  
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  


  
  
    Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  



  
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  


    
      
  
  
    
  
    Note:Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.Your expect block must accept a parameter and pass it on to the method-under-test as a block.
Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  

  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..toto yield_controlyield_control
expectexpect {{ ||bb|| ""aa"""a"..to_symto_sym((&&bb)) }}..not_tonot_to yield_controlyield_controlexpect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_controlexpect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  



  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  



  
    
      


866
867
868


866
867
868
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866# File 'lib/rspec/matchers.rb', line 866

defdef yield_controlyield_control
  BuiltInBuiltIn::::YieldControlYieldControl..newnew
endend# File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  

  
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  


  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  



  
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  


    
      
  
  
    
  
    Note:Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.Your expect block must accept a parameter and pass it on to the method-under-test as a block.
Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  

  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ ||bb|| [[11,, 22,, 33]]..eacheach((&&bb)) }}..toto yield_successive_argsyield_successive_args((11,, 22,, 33))
expectexpect {{ ||bb|| {{ :a:a =>=> 11,, :b:b =>=> 22 }}..eacheach((&&bb)) }}..toto yield_successive_argsyield_successive_args(([[:a:a,, 11]],, [[:b:b,, 22]]))
expectexpect {{ ||bb|| [[11,, 22,, 33]]..eacheach((&&bb)) }}..not_tonot_to yield_successive_argsyield_successive_args((11,, 22))expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  
    Examples:
    
      
      expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  



  
  
    Examples:
    
      
      expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  



  
    
      


935
936
937


935
936
937
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935# File 'lib/rspec/matchers.rb', line 935

defdef yield_successive_argsyield_successive_args((**argsargs))
  BuiltInBuiltIn::::YieldSuccessiveArgsYieldSuccessiveArgs..newnew((**argsargs))
endend# File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  

  
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  


  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  



  
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.Your expect block must accept a parameter and pass it on to the method-under-test as a block.
Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:Note:
    This matcher is not designed for use with methods that yield multiple times.This matcher is not designed for use with methods that yield multiple times.
This matcher is not designed for use with methods that yield multiple times.

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  

  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..toto yield_with_argsyield_with_args # because #tap yields an arg
# because #tap yields an arg
expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..toto yield_with_argsyield_with_args((55)) # because 5 == 5
# because 5 == 5
expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..toto yield_with_argsyield_with_args((IntegerInteger)) # because Integer === 5
# because Integer === 5
expectexpect {{ ||bb|| FileFile..openopen((""f.txtf.txt"""f.txt",, &&bb)) }}..toto yield_with_argsyield_with_args((//txttxt///txt/)) # because /txt/ === "f.txt"
# because /txt/ === "f.txt"

expectexpect {{ ||bb|| UserUser..transactiontransaction((&&bb)) }}..not_tonot_to yield_with_argsyield_with_args # because it yields no args
# because it yields no args
expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..not_tonot_to yield_with_argsyield_with_args((11,, 22,, 33))expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  



  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  



  
    
      


914
915
916


914
915
916
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914# File 'lib/rspec/matchers.rb', line 914

defdef yield_with_argsyield_with_args((**argsargs))
  BuiltInBuiltIn::::YieldWithArgsYieldWithArgs..newnew((**argsargs))
endend# File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  

  
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  


  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  



  
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.Your expect block must accept a parameter and pass it on to the method-under-test as a block.
Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:Note:
    This matcher is not designed for use with methods that yield multiple times.This matcher is not designed for use with methods that yield multiple times.
This matcher is not designed for use with methods that yield multiple times.

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  

  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  


  
  
    Examples:Examples:
    
      
      expectexpect {{ ||bb|| UserUser..transactiontransaction((&&bb)) }}..toto yield_with_no_argsyield_with_no_args
expectexpect {{ ||bb|| 55..taptap((&&bb)) }}..not_tonot_to yield_with_no_argsyield_with_no_args # because it yields with `5`
# because it yields with `5`
expectexpect {{ ||bb|| ""aa"""a"..to_symto_sym((&&bb)) }}..not_tonot_to yield_with_no_argsyield_with_no_args # because it does not yield# because it does not yieldexpect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yieldexpect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  
    Examples:
    
      
      expect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  



  
  
    Examples:
    
      
      expect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  



  
    
      


884
885
886


884
885
886
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884# File 'lib/rspec/matchers.rb', line 884

defdef yield_with_no_argsyield_with_no_args
  BuiltInBuiltIn::::YieldWithNoArgsYieldWithNoArgs..newnew
endend# File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  

  
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  


  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  


  
  
    Examples:
    
      
      expect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  



  
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  


    
  
    Instance Method Details

    
      
  
  
    
  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  


  
  
    Examples:
    
      
      aggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
Parameters:

  
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  


Yields:

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

Raises:

  
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  



  
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  


    
      
  
  
    
  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.


  


  
  
    Examples:
    
      
      expect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  



  
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  


    
      
  
  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  


  
  
    Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  



  
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  


    
      
  
  
    passes if target.kind_of?(klass).


  


  


  
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  


    
      
  
  
    Passes if actual.kind_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  



  
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.instance_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  



  
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  


  
  
    Examples:
    
      
      expect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  



  
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  


    
      
  
  
    Passes if actual is falsey (false or nil).


  


  


  
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  


    
      
  
  
    Passes if actual is nil.


  


  


  
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  


    
      
  
  
    Passes if actual is truthy (anything but false or nil).


  


  


  
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  


    
      
  
  
    Passes if actual == expected +/- delta.


  


  
  
    Examples:
    
      
      expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  



  
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  


    
      
  
  
    Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.


from
to


or any one of:.


by
by_at_least
by_at_most


== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  


  
  
    Examples:
    
      
      expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
Parameters:

  
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  




  
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  


    
      
  
  
    
  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  


  See Also:
  
    
      #match_array
    
  


  
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  


    
      
  
  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 only


  


  
  
    Examples:
    
      
      expect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  



  
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  


    
      
  
  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  



  
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  


    
      
  
  
    Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  



  
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  


    
      
  
  
    Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  



  
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  


    
      
  
  
    Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  



  
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  


    
      
  
  
    Passes if actual.exist? or actual.exists?.


  


  
  
    Examples:
    
      
      expect(File).to exist("path/to/file")
    
  



  
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  


    
      
  
  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  


  
  
    Examples:
    
      
      expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  

Returns:

  
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  


  See Also:
  
    
      Expectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_to
    
  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263


    
  


    
      
  
  
    
  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  


  
  
    Examples:
    
      
      Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expect(person).to have_attributes(:color => "red")
    
  



  
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  


    
      
  
  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  



  
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  


    
      
  
  
    
  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  


  
  
    Examples:
    
      
      expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  



  
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  


    
      
  
  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  


  
  
    Examples:
    
      
      expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  


  See Also:
  
    
      #contain_exactly
    
  


  
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  


    
      
  
  
    
  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  


  
  
    Examples:
    
      
      expect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  



  
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  


    
      
  
  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  



  
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  


    
      
  
  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  


  
  
    Examples:
    
      
      expect("string").to respond_to(:length)
    
  



  
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  


    
      
  
  
    :nocov:.


  


  
Returns:

  
    
      
      
        (Boolean)
      
      
      
    
  



  
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  


    
      
  
  
    Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  


  
  
    Examples:
    
      
      expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
Parameters:

  
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  




  
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  


    
      
  
  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  



  
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  


    
      
  
  
    Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  



  
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  



  
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  



  
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  



  
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  


  
  
    Examples:
    
      
      expect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  



  
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  


    
  

Module: RSpec::Matchers
  
  
  


  

  
  
  
      Extended by:
      DSL
  
  
  
  
  

  
  
    Included in:
    DSL::Matcher
  
  

  
  
    Defined in:
    lib/rspec/matchers.rb

  
  


Overview
  
    RSpec::Matchers provides a number of useful matchers we use to define expectations. Any object that implements the matcher protocol can be used as a matcher.

Predicates

In addition to matchers that are defined explicitly, RSpec will create custom matchers on the fly for any arbitrary predicate, giving your specs a much more natural language feel.

A Ruby predicate is a method that ends with a "?" and returns true or false. Common examples are empty?, nil?, and instance_of?.

All you need to do is write expect(..).to be_ followed by the predicate without the question mark, and RSpec will figure it out from there. For example:.

expect([]).to be_empty     # => [].empty?() | passes
expect([]).not_to be_empty # => [].empty?() | fails


In addtion to prefixing the predicate matchers with "be", you can also use "be_a" and "bean", making your specs read much more naturally:.

expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes

expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails


RSpec will also create custom matchers for predicates like has_key?. To use this feature, just state that the object should have_key(:key) and RSpec will call has_key?(:key) on the target. For example:.

expect(:a => "A").to have_key(:a)
expect(:a => "A").to have_key(:b) # fails


You can use this feature to invoke any predicate that begins with "has_", whether it is part of the Ruby libraries (like Hash#has_key?) or a method you wrote on your own class.

Note that RSpec does not provide composable aliases for these dynamic predicate matchers. You can easily define your own aliases, though:.

RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
expect(user_list).to include(a_user_who_is_an_admin)


Alias Matchers

With Matchers.alias_matcher, you can easily create an alternate name for a given matcher.

The description will also change according to the new name:.

RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
sum_to(3).description # => "sum to 3"
a_list_that_sums_to(3).description # => "a list that sums to 3"


or you can specify a custom description like this:.

RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  description.sub("be sorted by", "a list sorted by")
end

be_sorted_by(:age).description # => "be sorted by age"
a_list_sorted_by(:age).description # => "a list sorted by age"


Custom Matchers

When you find that none of the stock matchers provide a natural feeling expectation, you can very easily write your own using RSpec's matcher DSL or writing one from scratch.

Matcher DSL

Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:.

expect(bob.current_zone).to eql(Zone.new("4"))


But you might find it more expressive to say:.

expect(bob).to be_in_zone("4")


and/or.

expect(bob).not_to be_in_zone("3")


You can create such a matcher like so:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end
end


This will generate a be_in_zone method that returns a matcher with logical default messages for failures. You can override the failure messages and the generated description as follows:.

RSpec::Matchers.define :be_in_zone do |zone|
  match do |player|
    player.in_zone?(zone)
  end

  failure_message do |player|
    # generate and return the appropriate string.
  end

  failure_message_when_negated do |player|
    # generate and return the appropriate string.
  end

  description do
    # generate and return the appropriate string.
  end
end


Each of the message-generation methods has access to the block arguments passed to the create method (in this case, zone). The failure message methods (failure_message and failure_message_when_negated) are passed the actual value (the receiver of expect(..) or expect(..).not_to).

Custom Matcher from scratch

You could also write a custom matcher from scratch, as follows:.

class BeInZone
  def initialize(expected)
    @expected = expected
  end

  def matches?(target)
    @target = target
    @target.current_zone.eql?(Zone.new(@expected))
  end

  def failure_message
    "expected #{@target.inspect} to be in Zone #{@expected}"
  end

  def failure_message_when_negated
    "expected #{@target.inspect} not to be in Zone #{@expected}"
  end
end


... and a method like this:.

def be_in_zone(expected)
  BeInZone.new(expected)
end


And then expose the method to your specs. This is normally done by including the method and the class in a module, which is then included in your spec:.

module CustomGameMatchers
  class BeInZone
    # ...
  end

  def be_in_zone(expected)
    # ...
  end
end

describe "Player behaviour" do
  include CustomGameMatchers
  # ...
end


or you can include in globally in a spec_helper.rb file required from your spec file(s):.

RSpec::configure do |config|
  config.include(CustomGameMatchers)
end


Making custom matchers composable

RSpec's built-in matchers are designed to be composed, in expressions like:.

expect(["barn", 2.45]).to contain_exactly(
  a_value_within(0.1).of(2.5),
  a_string_starting_with("bar")
)


Custom matchers can easily participate in composed matcher expressions like these. Include Composable in your custom matcher to make it support being composed (matchers defined using the DSL have this included automatically). Within your matcher's matches? method (or the match block, if using the DSL), use values_match?(expected, actual) rather than expected == actual. Under the covers, values_match? is able to match arbitrary nested data structures containing a mix of both matchers and non-matcher objects. It uses === and == to perform the matching, considering the values to match if either returns true. The Composable mixin also provides some helper methods for surfacing the matcher descriptions within your matcher's description or failure messages.

RSpec's built-in matchers each have a number of aliases that rephrase the matcher from a verb phrase (such as be_within) to a noun phrase (such as a_value_within), which reads better when the matcher is passed as an argument in a composed matcher expressions, and also uses the noun-phrase wording in the matcher's description, for readable failure messages. You can alias your custom matchers in similar fashion using Matchers.alias_matcher.

Negated Matchers

Sometimes if you want to test for the opposite using a more descriptive name instead of using not_to, you can use Matchers.define_negated_matcher:.

RSpec::Matchers.define_negated_matcher :exclude, :include
include(1, 2).description # => "include 1 and 2"
exclude(1, 2).description # => "exclude 1 and 2"


While the most obvious negated form may be to add a not_ prefix, the failure messages you get with that form can be confusing (e.g. "expected [actual] to not [verb], but did not"). We've found it works best to find a more positive name for the negated form, such as avoid_changing rather than not_change.


  


  

Defined Under Namespace

  
    
      Modules: BuiltIn, Composable, DSL, EnglishPhrasing, FailMatchers
    
  
    
      Classes: AliasedMatcher, ExpectedsForMultipleDiffs, MatcherProtocol
    
  








  
    
      Class Method Summary
      
    

    
      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#alias_matcher.

  


      
        
  
  
  
  
  
  
  
  private

  
    Used by rspec-core to clear the state used to generate descriptions after an example.

  


      
        
  
  
  
  
  
  
  
  

  
    Delegates to Expectations.configuration.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define.

  


      
        
  
  
  
  
  
  
  
  

  
    Extended from DSL#define_negated_matcher.

  


      
        
  
  
  
  
  
  
  
  private

  
    Generates an an example description based on the last expectation.

  


      
    
  
    
      Instance Method Summary
      
    

    
      
        
  
  
  
  
  
  
  
  

  
    Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the provided matcher passes when checked against all elements of the collection.

  


      
        
  
  
  
  
  
  
  
  

  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively).

  


      
        
  
  
  
  
  
  
  
  

  
    passes if target.kind_of?(klass).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.kind_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.instance_of?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.between?(min, max).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is falsey (false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is nil.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual is truthy (anything but false or nil).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected +/- delta.

  


      
        
  
  
  
  
  
  
  
  

  
    Applied to a proc, specifies that its execution will cause some value to change.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual contains all of the expected regardless of order.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual covers expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value ends with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual == expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.eql?(expected).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.equal?(expected) (object identity).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual.exist? or actual.exists?.

  


      
        
  
  
  
  
  
  
  
  

  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual's attribute values match the expected attributes hash.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if actual includes expected.

  


      
        
  
  
  
  
  
  
  
  

  
    Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.

  


      
        
  
  
  
  
  
  
  
  

  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.

  


      
        
  
  
  
  
  
  
  
  

  
    With no arg, passes if the block outputs to_stdout or to_stderr.

  


      
        
  
  
  
  
  
  
  
  

  
    With no args, matches if any error is raised.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the target object responds to all of the names provided.

  


      
        
  
  
  
  
  
  
  
  

  
    :nocov:.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the submitted block returns true.

  


      
        
  
  
  
  
  
  
  
  

  
    Matches if the actual value starts with the expected value(s).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no argument, matches if a proc throws any Symbol.

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.

  


      
        
  
  
  
  
  
  
  
  

  
    Designed for use with methods that repeatedly yield (such as iterators).

  


      
        
  
  
  
  
  
  
  
  

  
    Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

  


      
        
  
  
  
  
  
  
  
  

  
    Passes if the method called in the expect block yields with no arguments.

  


      
    
  


  
  
  
  
  
  
  
  
  Methods included from DSL
  alias_matcher, define, define_negated_matcher

  Dynamic Method Handling
  
    This class handles dynamic methods through the method_missing method
    
  
  
    
  
  
    
      


956
957
958
959
960
961
962
963
964
965
    
    
      # File 'lib/rspec/matchers.rb', line 956

def method_missing(method, *args, &block)
  case method.to_s
  when BE_PREDICATE_REGEX
    BuiltIn::BePredicate.new(method, *args, &block)
  when HAS_REGEX
    BuiltIn::Has.new(method, *args, &block)
  else
    super
  end
end
    
  


  



  
    Class Method Details

    
      
  
  
    Extended from RSpec::Matchers::DSL#alias_matcher.


  


  


  
    
      


250
251
252
    
    
      # File 'lib/rspec/matchers.rb', line 250

def self.alias_matcher(*args, &block)
  super(*args, &block)
end
    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Used by rspec-core to clear the state used to generate descriptions after an example.


  


  


  
    
      


11
12
13
14
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 11

def self.clear_generated_description
  self.last_matcher = nil
  self.last_expectation_handler = nil
end
    
  


    
      
  
  
    Delegates to Expectations.configuration. This is here because rspec-core's expect_with option looks for a configuration method on the mixin (RSpec::Matchers) to yield to a block.


  


  
Returns:

  
    
      
      
        (RSpec::Expectations::Configuration)
      
      
      
        —
        the configuration object

      
    
  



  
    
      


946
947
948
    
    
      # File 'lib/rspec/matchers.rb', line 946

def self.configuration
  Expectations.configuration
end
    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 257


    
  


    
      
  
  
    Extended from RSpec::Matchers::DSL#define_negated_matcher.


  


  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 260


    
  


    
      
  
  
       This method is part of a private API.   You should avoid using this method if possible, as it may be removed or be changed in the future. .
Generates an an example description based on the last expectation. Used by rspec-core's one-liner syntax.


  


  


  
    
      


19
20
21
22
    
    
      # File 'lib/rspec/matchers/generated_descriptions.rb', line 19

def self.generated_description
  return nil if last_expectation_handler.nil?
  "#{last_expectation_handler.verb} #{last_description}"
end
    
  


    
  

  
    Instance Method Details

    
      
  
  
    
  
    Note:
    The implementation of this feature uses a thread-local variable, which means that if you have an expectation failure in another thread, it'll abort like normal.

  

Allows multiple expectations in the provided block to fail, and then aggregates them into a single exception, rather than aborting on the first expectation failure like normal. This allows you to see all failures from an entire set of expectations without splitting each off into its own example (which may slow things down if the example setup is expensive).


  


  
  
    Examples:
    
      
      aggregate_failures("verifying response") do
  expect(response.status).to eq(200)
  expect(response.headers).to include("Content-Type" => "text/plain")
  expect(response.body).to include("Success")
end
    
  
Parameters:

  
    
      
        label
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        label for this aggregation block, which will be included in the aggregated exception message.

      
    
  
    
      
        metadata
      
      
        (Hash)
      
      
        (defaults to: {})
      
      
        —
        additional metadata about this failure aggregation block. If multiple expectations fail, it will be exposed from the Expectations::MultipleExpectationsNotMetError exception. Mostly intended for internal RSpec use but you can use it as well.

      
    
  


Yields:

  
    
      
      
        
      
      
      
        
        Block containing as many expectation as you want. The block is simply yielded to, so you can trust that anything that works outside the block should work within it.

      
    
  

Raises:

  
    
      
      
        (Expectations::MultipleExpectationsNotMetError)
      
      
      
        —
        raised when multiple expectations fail.

      
    
  
    
      
      
        (Expectations::ExpectationNotMetError)
      
      
      
        —
        raised when a single expectation fails.

      
    
  
    
      
      
        (Exception)
      
      
      
        —
        other sorts of exceptions will be raised as normal.

      
    
  



  
    
      


305
306
307
    
    
      # File 'lib/rspec/matchers.rb', line 305

def aggregate_failures(label=nil, metadata={}, &block)
  Expectations::FailureAggregator.new(label, metadata).aggregate(&block)
end
    
  


    
      
  
  
    
  
    Note:
    The negative form not_to all is not supported. Instead use not_to include or pass a negative form of a matcher as the argument (e.g. all exclude(:foo)).

  

  
    Note:
    You can also use this with compound matchers as well.

  

Passes if the provided matcher passes when checked against all elements of the collection.


  


  
  
    Examples:
    
      
      expect([1, 3, 5]).to all be_odd
expect([1, 3, 6]).to all be_odd # fails
    
      
      expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
    
  



  
    
      


662
663
664
    
    
      # File 'lib/rspec/matchers.rb', line 662

def all(expected)
  BuiltIn::All.new(expected)
end
    
  


    
      
  
  
    Given true, false, or nil, will pass if actual value is true, false or nil (respectively). Given no args means the caller should satisfy an if condition (to be or not to be).

Predicates are any Ruby method that ends in a "?" and returns true or false.  Given be_ followed by arbitrary_predicate (without the "?"), RSpec will match convert that into a query against the target object.

The arbitrarypredicate feature will handle any predicate prefixed with "be_an" (e.g. bean_instance_of), "be_a" (e.g. bea_kind_of) or "be" (e.g. be_empty), letting you choose the prefix that best suits the predicate.


  


  
  
    Examples:
    
      
      expect(actual).to     be_truthy
expect(actual).to     be_falsey
expect(actual).to     be_nil
expect(actual).to     be_[arbitrary_predicate](*args)
expect(actual).not_to be_nil
expect(actual).not_to be_[arbitrary_predicate](*args)
    
  



  
    
      


349
350
351
    
    
      # File 'lib/rspec/matchers.rb', line 349

def be(*args)
  args.empty? ? Matchers::BuiltIn::Be.new : equal(*args)
end
    
  


    
      
  
  
    passes if target.kind_of?(klass).


  


  


  
    
      


355
356
357
    
    
      # File 'lib/rspec/matchers.rb', line 355

def be_a(klass)
  be_a_kind_of(klass)
end
    
  


    
      
  
  
    Passes if actual.kind_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_a_kind_of(Integer)
expect(5).to     be_a_kind_of(Numeric)
expect(5).not_to be_a_kind_of(Float)
    
  



  
    
      


378
379
380
    
    
      # File 'lib/rspec/matchers.rb', line 378

def be_a_kind_of(expected)
  BuiltIn::BeAKindOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.instance_of?(expected).


  


  
  
    Examples:
    
      
      expect(5).to     be_an_instance_of(Integer)
expect(5).not_to be_an_instance_of(Numeric)
expect(5).not_to be_an_instance_of(Float)
    
  



  
    
      


366
367
368
    
    
      # File 'lib/rspec/matchers.rb', line 366

def be_an_instance_of(expected)
  BuiltIn::BeAnInstanceOf.new(expected)
end
    
  


    
      
  
  
    Passes if actual.between?(min, max). Works with any Comparable object, including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer, Float, Complex, and Rational).

By default, be_between is inclusive (i.e. passes when given either the max or min value), but you can make it exclusive by chaining that off the matcher.


  


  
  
    Examples:
    
      
      expect(5).to      be_between(1, 10)
expect(11).not_to be_between(1, 10)
expect(10).not_to be_between(1, 10).exclusive
    
  



  
    
      


395
396
397
    
    
      # File 'lib/rspec/matchers.rb', line 395

def be_between(min, max)
  BuiltIn::BeBetween.new(min, max)
end
    
  


    
      
  
  
    Passes if actual is falsey (false or nil).


  


  


  
    
      


316
317
318
    
    
      # File 'lib/rspec/matchers.rb', line 316

def be_falsey
  BuiltIn::BeFalsey.new
end
    
  


    
      
  
  
    Passes if actual is nil.


  


  


  
    
      


324
325
326
    
    
      # File 'lib/rspec/matchers.rb', line 324

def be_nil
  BuiltIn::BeNil.new
end
    
  


    
      
  
  
    Passes if actual is truthy (anything but false or nil).


  


  


  
    
      


310
311
312
    
    
      # File 'lib/rspec/matchers.rb', line 310

def be_truthy
  BuiltIn::BeTruthy.new
end
    
  


    
      
  
  
    Passes if actual == expected +/- delta.


  


  
  
    Examples:
    
      
      expect(result).to     be_within(0.5).of(3.0)
expect(result).not_to be_within(0.5).of(3.0)
    
  



  
    
      


405
406
407
    
    
      # File 'lib/rspec/matchers.rb', line 405

def be_within(delta)
  BuiltIn::BeWithin.new(delta)
end
    
  


    
      
  
  
    Applied to a proc, specifies that its execution will cause some value to change.

You can either pass receiver and message, or a block, but not both.

When passing a block, it must use the { ... } format, not do/end, as { ... } binds to the change method, whereas do/end would errantly bind to the expect(..).to or expect(...).not_to method.

You can chain any of the following off of the end to specify details about the change:.


from
to


or any one of:.


by
by_at_least
by_at_most


== Notes.

Evaluates receiver.message or block before and after it evaluates the block passed to expect. If the value is the same object, its before/after hash value is used to see if it has changed. Therefore, your object needs to properly implement hash to work correctly with this matcher.

expect( ... ).not_to change supports the form that specifies from (which specifies what you expect the starting, unchanged value to be) but does not support forms with subsequent calls to by, by_at_least, by_at_most or to.


  


  
  
    Examples:
    
      
      expect {
  team.add_player(player)
}.to change(roster, :count)

expect {
  team.add_player(player)
}.to change(roster, :count).by(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_least(1)

expect {
  team.add_player(player)
}.to change(roster, :count).by_at_most(1)

string = "string"
expect {
  string.reverse!
}.to change { string }.from("string").to("gnirts")

string = "string"
expect {
  string
}.not_to change { string }.from("string")

expect {
  person.happy_birthday
}.to change(person, :birthday).from(32).to(33)

expect {
  employee.develop_great_new_social_networking_app
}.to change(employee, :title).from("Mail Clerk").to("CEO")

expect {
  doctor.leave_office
}.to change(doctor, :sign).from(/is in/).to(/is out/)

user = User.new(:type => "admin")
expect {
  user.symbolize_type
}.to change(user, :type).from(String).to(Symbol)
    
  
Parameters:

  
    
      
        receiver
      
      
        (Object)
      
      
        (defaults to: nil)
      
      
    
  
    
      
        message
      
      
        (Symbol)
      
      
        (defaults to: nil)
      
      
        —
        the message to send the receiver

      
    
  




  
    
      


492
493
494
    
    
      # File 'lib/rspec/matchers.rb', line 492

def change(receiver=nil, message=nil, &block)
  BuiltIn::Change.new(receiver, message, &block)
end
    
  


    
      
  
  
    
  
    Note:
    This is also available using the =~ operator with should, but =~ is not supported with expect.

  

Passes if actual contains all of the expected regardless of order. This works for collections. Pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1, 2, 3]).to contain_exactly(1, 2, 3)
expect([1, 2, 3]).to contain_exactly(1, 3, 2)
    
  


  See Also:
  
    
      #match_array
    
  


  
    
      


510
511
512
    
    
      # File 'lib/rspec/matchers.rb', line 510

def contain_exactly(*items)
  BuiltIn::ContainExactly.new(items)
end
    
  


    
      
  
  
    Passes if actual covers expected. This works for Ranges. You can also pass in multiple args and it will only pass if all args are found in Range.

Warning:: Ruby >= 1.9 only


  


  
  
    Examples:
    
      
      expect(1..10).to     cover(5)
expect(1..10).to     cover(4, 6)
expect(1..10).to     cover(4, 6, 11) # fails
expect(1..10).not_to cover(11)
expect(1..10).not_to cover(5)        # fails
    
  



  
    
      


528
529
530
    
    
      # File 'lib/rspec/matchers.rb', line 528

def cover(*values)
  BuiltIn::Cover.new(*values)
end
    
  


    
      
  
  
    Matches if the actual value ends with the expected value(s). In the case of a string, matches against the last expected.length characters of the actual string. In the case of an array, matches against the last expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   end_with "string"
expect([0, 1, 2, 3, 4]).to end_with 4
expect([0, 2, 3, 4, 4]).to end_with 3, 4
    
  



  
    
      


543
544
545
    
    
      # File 'lib/rspec/matchers.rb', line 543

def end_with(*expected)
  BuiltIn::EndWith.new(*expected)
end
    
  


    
      
  
  
    Passes if actual == expected.

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eq(5)
expect(5).not_to eq(3)
    
  



  
    
      


558
559
560
    
    
      # File 'lib/rspec/matchers.rb', line 558

def eq(expected)
  BuiltIn::Eq.new(expected)
end
    
  


    
      
  
  
    Passes if actual.eql?(expected).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to     eql(5)
expect(5).not_to eql(3)
    
  



  
    
      


572
573
574
    
    
      # File 'lib/rspec/matchers.rb', line 572

def eql(expected)
  BuiltIn::Eql.new(expected)
end
    
  


    
      
  
  
    Passes if actual.equal?(expected) (object identity).

See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more information about equality in Ruby.


  


  
  
    Examples:
    
      
      expect(5).to       equal(5)   # Integers are equal
expect("5").not_to equal("5") # Strings that look the same are not the same object
    
  



  
    
      


586
587
588
    
    
      # File 'lib/rspec/matchers.rb', line 586

def equal(expected)
  BuiltIn::Equal.new(expected)
end
    
  


    
      
  
  
    Passes if actual.exist? or actual.exists?.


  


  
  
    Examples:
    
      
      expect(File).to exist("path/to/file")
    
  



  
    
      


596
597
598
    
    
      # File 'lib/rspec/matchers.rb', line 596

def exist(*args)
  BuiltIn::Exist.new(*args)
end
    
  


    
      
  
  
    Supports expect(actual).to matcher syntax by wrapping actual in an ExpectationTarget.


  


  
  
    Examples:
    
      
      expect(actual).to eq(expected)
expect(actual).not_to eq(expected)
    
  

Returns:

  
    
      
      
        (Expectations::ExpectationTarget)
      
      
      
    
  


  See Also:
  
    
      Expectations::ExpectationTarget::InstanceMethods#to
    
      Expectations::ExpectationTarget::InstanceMethods#not_to
    
  


  
    
      



    
    
      # File 'lib/rspec/matchers.rb', line 263


    
  


    
      
  
  
    
  
    Note:
    It will fail if actual doesn't respond to any of the expected attributes.

  

Passes if actual's attribute values match the expected attributes hash. This works no matter how you define your attribute readers.


  


  
  
    Examples:
    
      
      Person = Struct.new(:name, :age)
person = Person.new("Bob", 32)

expect(person).to have_attributes(:name => "Bob", :age => 32)
expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
    
      
      expect(person).to have_attributes(:color => "red")
    
  



  
    
      


616
617
618
    
    
      # File 'lib/rspec/matchers.rb', line 616

def have_attributes(expected)
  BuiltIn::HaveAttributes.new(expected)
end
    
  


    
      
  
  
    Passes if actual includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.


  


  
  
    Examples:
    
      
      expect([1,2,3]).to      include(3)
expect([1,2,3]).to      include(2,3)
expect([1,2,3]).to      include(2,3,4) # fails
expect([1,2,3]).not_to  include(4)
expect("spread").to     include("read")
expect("spread").not_to include("red")
expect(:a => 1, :b => 2).to include(:a)
expect(:a => 1, :b => 2).to include(:a, :b)
expect(:a => 1, :b => 2).to include(:a => 1)
expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
expect(:a => 1, :b => 2).to include(:c) # fails
expect(:a => 1, :b => 2).not_to include(:a => 2)
    
  



  
    
      


639
640
641
    
    
      # File 'lib/rspec/matchers.rb', line 639

def include(*expected)
  BuiltIn::Include.new(*expected)
end
    
  


    
      
  
  
    
  
    Note:
    The match_regex alias is deprecated and is not recommended for use. It was added in 2.12.1 to facilitate its use from within custom matchers (due to how the custom matcher DSL was evaluated in 2.x, match could not be used there), but is no longer needed in 3.x.

  

Given a Regexp or String, passes if actual.match(pattern) Given an arbitrary nested data structure (e.g. arrays and hashes), matches if expected === actual || actual == expected for each pair of elements.


  


  
  
    Examples:
    
      
      expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
expect(email).to match("@example.com")
    
      
      hash = {
  :a => {
    :b => ["foo", 5],
    :c => { :d => 2.05 }
  }
}

expect(hash).to match(
  :a => {
    :b => a_collection_containing_exactly(
      a_string_starting_with("f"),
      an_instance_of(Integer)
    ),
    :c => { :d => (a_value < 3) }
  }
)
    
  



  
    
      


697
698
699
    
    
      # File 'lib/rspec/matchers.rb', line 697

def match(expected)
  BuiltIn::Match.new(expected)
end
    
  


    
      
  
  
    An alternate form of contain_exactly that accepts the expected contents as a single array arg rather that splatted out as individual items.


  


  
  
    Examples:
    
      
      expect(results).to contain_exactly(1, 2)
# is identical to:
expect(results).to match_array([1, 2])
    
  


  See Also:
  
    
      #contain_exactly
    
  


  
    
      


715
716
717
    
    
      # File 'lib/rspec/matchers.rb', line 715

def match_array(items)
  contain_exactly(*items)
end
    
  


    
      
  
  
    
  
    Note:
    to_stdout and to_stderr work by temporarily replacing $stdout or $stderr, so they're not able to intercept stream output that explicitly uses STDOUT/STDERR or that uses a reference to $stdout/$stderr that was stored before the matcher was used.

  

  
    Note:
    to_stdout_from_any_process and to_stderr_from_any_process use Tempfiles, and are thus significantly (~30x) slower than to_stdout and to_stderr.

  

With no arg, passes if the block outputs to_stdout or to_stderr. With a string, passes if the block outputs that specific string to_stdout or to_stderr. With a regexp or matcher, passes if the block outputs a string to_stdout or to_stderr that matches.

To capture output from any spawned subprocess as well, use to_stdout_from_any_process or to_stderr_from_any_process. Output from any process that inherits the main process's corresponding standard stream will be captured.


  


  
  
    Examples:
    
      
      expect { print 'foo' }.to output.to_stdout
expect { print 'foo' }.to output('foo').to_stdout
expect { print 'foo' }.to output(/foo/).to_stdout

expect { do_something }.to_not output.to_stdout

expect { warn('foo') }.to output.to_stderr
expect { warn('foo') }.to output('foo').to_stderr
expect { warn('foo') }.to output(/foo/).to_stderr

expect { do_something }.to_not output.to_stderr

expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
    
  



  
    
      


749
750
751
    
    
      # File 'lib/rspec/matchers.rb', line 749

def output(expected=nil)
  BuiltIn::Output.new(expected)
end
    
  


    
      
  
  
    With no args, matches if any error is raised. With a named error, matches only if that specific error is raised. With a named error and messsage specified as a String, matches only if both match. With a named error and messsage specified as a Regexp, matches only if both match. Pass an optional block to perform extra verifications on the exception matched.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to raise_error
expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)

expect { do_something_risky }.not_to raise_error
    
  



  
    
      


768
769
770
    
    
      # File 'lib/rspec/matchers.rb', line 768

def raise_error(error=nil, message=nil, &block)
  BuiltIn::RaiseError.new(error, message, &block)
end
    
  


    
      
  
  
    Matches if the target object responds to all of the names provided. Names can be Strings or Symbols.


  


  
  
    Examples:
    
      
      expect("string").to respond_to(:length)
    
  



  
    
      


787
788
789
    
    
      # File 'lib/rspec/matchers.rb', line 787

def respond_to(*names)
  BuiltIn::RespondTo.new(*names)
end
    
  


    
      
  
  
    :nocov:.


  


  
Returns:

  
    
      
      
        (Boolean)
      
      
      
    
  



  
    
      


973
974
975
976
    
    
      # File 'lib/rspec/matchers.rb', line 973

def respond_to?(method, *)
  method = method.to_s
  method =~ DYNAMIC_MATCHER_REGEX || super
end
    
  


    
      
  
  
    Passes if the submitted block returns true. Yields target to the block.

Generally speaking, this should be thought of as a last resort when you can't find any other way to specify the behaviour you wish to specify.

If you do find yourself in such a situation, you could always write a custom matcher, which would likely make your specs more expressive.


  


  
  
    Examples:
    
      
      expect(5).to satisfy { |n| n > 3 }
expect(5).to satisfy("be greater than 3") { |n| n > 3 }
    
  
Parameters:

  
    
      
        description
      
      
        (String)
      
      
        (defaults to: nil)
      
      
        —
        optional description to be used for this matcher.

      
    
  




  
    
      


808
809
810
    
    
      # File 'lib/rspec/matchers.rb', line 808

def satisfy(description=nil, &block)
  BuiltIn::Satisfy.new(description, &block)
end
    
  


    
      
  
  
    Matches if the actual value starts with the expected value(s). In the case of a string, matches against the first expected.length characters of the actual string. In the case of an array, matches against the first expected.length elements of the actual array.


  


  
  
    Examples:
    
      
      expect("this string").to   start_with "this s"
expect([0, 1, 2, 3, 4]).to start_with 0
expect([0, 2, 3, 4, 4]).to start_with 0, 1
    
  



  
    
      


823
824
825
    
    
      # File 'lib/rspec/matchers.rb', line 823

def start_with(*expected)
  BuiltIn::StartWith.new(*expected)
end
    
  


    
      
  
  
    Given no argument, matches if a proc throws any Symbol.

Given a Symbol, matches if the given proc throws the specified Symbol.

Given a Symbol and an arg, matches if the given proc throws the specified Symbol with the specified arg.


  


  
  
    Examples:
    
      
      expect { do_something_risky }.to throw_symbol
expect { do_something_risky }.to throw_symbol(:that_was_risky)
expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')

expect { do_something_risky }.not_to throw_symbol
expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
    
  



  
    
      


845
846
847
    
    
      # File 'lib/rspec/matchers.rb', line 845

def throw_symbol(expected_symbol=nil, expected_arg=nil)
  BuiltIn::ThrowSymbol.new(expected_symbol, expected_arg)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Passes if the method called in the expect block yields, regardless of whether or not arguments are yielded.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_control
expect { |b| "a".to_sym(&b) }.not_to yield_control
    
  



  
    
      


866
867
868
    
    
      # File 'lib/rspec/matchers.rb', line 866

def yield_control
  BuiltIn::YieldControl.new
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

Designed for use with methods that repeatedly yield (such as iterators). Passes if the method called in the expect block yields multiple times with arguments matching those given.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
    
  



  
    
      


935
936
937
    
    
      # File 'lib/rspec/matchers.rb', line 935

def yield_successive_args(*args)
  BuiltIn::YieldSuccessiveArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Given no arguments, matches if the method called in the expect block yields with arguments (regardless of what they are or how many there are).

Given arguments, matches if the method called in the expect block yields with arguments that match the given arguments.

Argument matching is done using === (the case match operator) and ==. If the expected and actual arguments match with either operator, the matcher will pass.


  


  
  
    Examples:
    
      
      expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"

expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
    
  



  
    
      


914
915
916
    
    
      # File 'lib/rspec/matchers.rb', line 914

def yield_with_args(*args)
  BuiltIn::YieldWithArgs.new(*args)
end
    
  


    
      
  
  
    
  
    Note:
    Your expect block must accept a parameter and pass it on to the method-under-test as a block.

  

  
    Note:
    This matcher is not designed for use with methods that yield multiple times.

  

Passes if the method called in the expect block yields with no arguments. Fails if it does not yield, or yields with arguments.


  


  
  
    Examples:
    
      
      expect { |b| User.transaction(&b) }.to yield_with_no_args
expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
    
  



  
    
      


884
885
886
    
    
      # File 'lib/rspec/matchers.rb', line 884

def yield_with_no_args
  BuiltIn::YieldWithNoArgs.new
end
    
  


    
  

